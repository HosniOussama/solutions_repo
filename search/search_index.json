{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is a fundamental concept in physics, illustrating how objects move under gravity. This study explores how the range of a projectile depends on its launch angle, uncovering both theoretical and computational insights. Theoretical Foundation The motion of a projectile follows these kinematic equations: Horizontal motion: \\(x = v_0 \\cos(\\theta) t\\) Vertical motion: \\(y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) Time of flight: \\(T = \\frac{2 v_0 \\sin(\\theta)}{g}\\) Range equation: \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) Python Simulation import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) theta = np.linspace(0, np.pi/2, 100) R = (v0**2 * np.sin(2*theta)) / g plt.plot(np.degrees(theta), R) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show() Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum exhibits complex behaviors such as resonance and chaos. Understanding its motion helps in various applications, from engineering to climate models. Theoretical Foundation The equation of motion for a forced damped pendulum is: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t)\\) Python Simulation from scipy.integrate import solve_ivp def pendulum(t, y, b, w0, A, w): theta, omega = y return [omega, -b*omega - w0**2*np.sin(theta) + A*np.cos(w*t)] b, w0, A, w = 0.1, 1.0, 0.5, 2.0 t = np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, [0, 50], [np.pi/4, 0], args=(b, w0, A, w), t_eval=t) plt.plot(t, sol.y[0]) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.grid() plt.show() Orbital Period and Orbital Radius Motivation Kepler's Third Law states that the square of the orbital period is proportional to the cube of the orbital radius. This principle is key in astrophysics and satellite design. Theoretical Foundation For circular orbits: \\(T^2 = \\frac{4\\pi^2 r^3}{GM}\\) Python Simulation G = 6.674e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) r = np.linspace(6.7e6, 4e7, 100) # Orbital radius range (m) T = 2 * np.pi * np.sqrt(r**3 / (G * M)) plt.plot(r / 1e6, T / 3600) plt.xlabel(\"Orbital Radius (million m)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs. Radius\") plt.grid() plt.show() Conclusion These simulations provide insights into projectile motion, pendulums, and orbits, demonstrating their dependence on key parameters. Further refinements could include air resistance and non-linear effects to enhance realism.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is a fundamental concept in physics, illustrating how objects move under gravity. This study explores how the range of a projectile depends on its launch angle, uncovering both theoretical and computational insights.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"The motion of a projectile follows these kinematic equations: Horizontal motion: \\(x = v_0 \\cos(\\theta) t\\) Vertical motion: \\(y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) Time of flight: \\(T = \\frac{2 v_0 \\sin(\\theta)}{g}\\) Range equation: \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\)","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) theta = np.linspace(0, np.pi/2, 100) R = (v0**2 * np.sin(2*theta)) / g plt.plot(np.degrees(theta), R) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation_1","text":"The forced damped pendulum exhibits complex behaviors such as resonance and chaos. Understanding its motion helps in various applications, from engineering to climate models.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation_1","text":"The equation of motion for a forced damped pendulum is: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t)\\)","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation_1","text":"from scipy.integrate import solve_ivp def pendulum(t, y, b, w0, A, w): theta, omega = y return [omega, -b*omega - w0**2*np.sin(theta) + A*np.cos(w*t)] b, w0, A, w = 0.1, 1.0, 0.5, 2.0 t = np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, [0, 50], [np.pi/4, 0], args=(b, w0, A, w), t_eval=t) plt.plot(t, sol.y[0]) plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.grid() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation_2","text":"Kepler's Third Law states that the square of the orbital period is proportional to the cube of the orbital radius. This principle is key in astrophysics and satellite design.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation_2","text":"For circular orbits: \\(T^2 = \\frac{4\\pi^2 r^3}{GM}\\)","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation_2","text":"G = 6.674e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) r = np.linspace(6.7e6, 4e7, 100) # Orbital radius range (m) T = 2 * np.pi * np.sqrt(r**3 / (G * M)) plt.plot(r / 1e6, T / 3600) plt.xlabel(\"Orbital Radius (million m)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs. Radius\") plt.grid() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_3","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"These simulations provide insights into projectile motion, pendulums, and orbits, demonstrating their dependence on key parameters. Further refinements could include air resistance and non-linear effects to enhance realism.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating system where damping, restoring forces, and external periodic forcing interact to create diverse motion patterns. The system transitions from simple harmonic motion to resonance, chaos, and quasiperiodic behavior. These dynamics are essential in various real-world applications, including energy harvesting, structural engineering, and nonlinear oscillatory systems. By systematically varying damping, driving amplitude, and driving frequency, we can observe different behaviors such as synchronized oscillations, resonance, and chaotic motion. Understanding these phenomena helps in designing better mechanical systems, reducing unwanted vibrations, and optimizing energy transfer in oscillatory systems. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = A \\cos(\\omega t)\\] where: \\(\\theta\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(g\\) is gravitational acceleration, \\(l\\) is the length of the pendulum, \\(A\\) is the amplitude of the external forcing, \\(\\omega\\) is the driving frequency. Small-Angle Approximation For small angles ( \\(\\theta\\approx\\) \\(\\sin\\) \\(\\theta\\) ), the equation simplifies to: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\theta = A \\cos(\\omega t)\\] This is a damped, driven harmonic oscillator with an analytical solution in the form: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t + \\phi)\\] where \\(\\theta_0\\) is the initial amplitude, and \\(\\phi\\) is a phase shift. Resonance Conditions Resonance occurs when the driving frequency matches the system's natural frequency: \\[\\omega = \\sqrt{\\frac{g}{l} - \\frac{b^2}{4}}\\] At resonance, the system absorbs maximum energy, leading to large oscillations. 2. Analysis of Dynamics Effect of Parameters on Motion Damping Coefficient ( \\(b\\) ): Higher damping reduces oscillations and suppresses chaotic motion. Driving Amplitude ( \\(A\\) ): Increased forcing can lead to resonance or chaotic behavior. Driving Frequency ( \\(\\omega\\) ): Tuning the frequency can shift the system from periodic to chaotic regimes. Chaos and Transition to Irregular Motion When forcing is strong and damping is moderate, the system can enter chaotic motion, characterized by sensitive dependence on initial conditions. This is analyzed using Poincar\u00e9 sections and bifurcation diagrams . 3. Practical Applications Energy Harvesting: Used in devices that convert oscillatory motion into electricity. Suspension Bridges: Understanding resonance helps prevent structural failures (e.g., Tacoma Narrows Bridge collapse). Biomechanics: Models human gait and oscillatory movements. Electrical Circuits: Analogous to driven RLC circuits. 4. Computational Model & Simulations We use Python to simulate the forced damped pendulum with the Runge-Kutta method for numerical integration. Python Script (forced_damped_pendulum.py) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s^2) l = 1.0 # Length of pendulum (m) b = 0.2 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Equations of motion def pendulum_eq(t, y): theta, omega_p = y dtheta_dt = omega_p domega_dt = -b * omega_p - (g/l) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = [0, 50] y0 = [0.5, 0] # Initial angle and velocity t_eval = np.linspace(0, 50, 1000) # Solve the system sol = solve_ivp(pendulum_eq, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 5. Graphical Representations 1. Time Evolution of Motion (Plot showing pendulum angle over time.) 2. Phase Portraits \\(\\text{Plot }\\) ( \\(\\theta, \\dot{\\theta}\\) ) \\(\\text{ to visualize motion in phase space.}\\) 3. Poincar\u00e9 Sections \\[\\text{Stroboscopic map of the system, revealing periodic or chaotic behavior.}\\] 4. Bifurcation Diagrams \\[\\text{Graph showing transition to chaos as the driving force increases.}\\] 6. Discussion on Model Limitations & Extensions Limitations *The small-angle approximation fails for large oscillations * *The model assumes a simple sinusoidal driving force. * Possible Extensions Nonlinear Damping: More realistic energy dissipation models Non-Periodic Forcing: Studying real-world irregular driving forces. Coupled Pendulums: Exploring synchronization and complex dynamics. Conclusion The forced damped pendulum provides insights into nonlinear dynamics, resonance, and chaos. By tuning parameters, we observe a transition from regular motion to chaos, revealing fundamental principles that apply to various fields of science and engineering.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating system where damping, restoring forces, and external periodic forcing interact to create diverse motion patterns. The system transitions from simple harmonic motion to resonance, chaos, and quasiperiodic behavior. These dynamics are essential in various real-world applications, including energy harvesting, structural engineering, and nonlinear oscillatory systems. By systematically varying damping, driving amplitude, and driving frequency, we can observe different behaviors such as synchronized oscillations, resonance, and chaotic motion. Understanding these phenomena helps in designing better mechanical systems, reducing unwanted vibrations, and optimizing energy transfer in oscillatory systems.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = A \\cos(\\omega t)\\] where: \\(\\theta\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(g\\) is gravitational acceleration, \\(l\\) is the length of the pendulum, \\(A\\) is the amplitude of the external forcing, \\(\\omega\\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta\\approx\\) \\(\\sin\\) \\(\\theta\\) ), the equation simplifies to: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\theta = A \\cos(\\omega t)\\] This is a damped, driven harmonic oscillator with an analytical solution in the form: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t + \\phi)\\] where \\(\\theta_0\\) is the initial amplitude, and \\(\\phi\\) is a phase shift.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency matches the system's natural frequency: \\[\\omega = \\sqrt{\\frac{g}{l} - \\frac{b^2}{4}}\\] At resonance, the system absorbs maximum energy, leading to large oscillations.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-parameters-on-motion","text":"Damping Coefficient ( \\(b\\) ): Higher damping reduces oscillations and suppresses chaotic motion. Driving Amplitude ( \\(A\\) ): Increased forcing can lead to resonance or chaotic behavior. Driving Frequency ( \\(\\omega\\) ): Tuning the frequency can shift the system from periodic to chaotic regimes.","title":"Effect of Parameters on Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-and-transition-to-irregular-motion","text":"When forcing is strong and damping is moderate, the system can enter chaotic motion, characterized by sensitive dependence on initial conditions. This is analyzed using Poincar\u00e9 sections and bifurcation diagrams .","title":"Chaos and Transition to Irregular Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting: Used in devices that convert oscillatory motion into electricity. Suspension Bridges: Understanding resonance helps prevent structural failures (e.g., Tacoma Narrows Bridge collapse). Biomechanics: Models human gait and oscillatory movements. Electrical Circuits: Analogous to driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-model-simulations","text":"We use Python to simulate the forced damped pendulum with the Runge-Kutta method for numerical integration.","title":"4. Computational Model &amp; Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-script-forced_damped_pendulumpy","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s^2) l = 1.0 # Length of pendulum (m) b = 0.2 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Equations of motion def pendulum_eq(t, y): theta, omega_p = y dtheta_dt = omega_p domega_dt = -b * omega_p - (g/l) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = [0, 50] y0 = [0.5, 0] # Initial angle and velocity t_eval = np.linspace(0, 50, 1000) # Solve the system sol = solve_ivp(pendulum_eq, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Python Script (forced_damped_pendulum.py)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-graphical-representations","text":"","title":"5. Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-time-evolution-of-motion","text":"(Plot showing pendulum angle over time.)","title":"1. Time Evolution of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-phase-portraits","text":"\\(\\text{Plot }\\) ( \\(\\theta, \\dot{\\theta}\\) ) \\(\\text{ to visualize motion in phase space.}\\)","title":"2. Phase Portraits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-poincare-sections","text":"\\[\\text{Stroboscopic map of the system, revealing periodic or chaotic behavior.}\\]","title":"3. Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-bifurcation-diagrams","text":"\\[\\text{Graph showing transition to chaos as the driving force increases.}\\]","title":"4. Bifurcation Diagrams"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-discussion-on-model-limitations-extensions","text":"","title":"6. Discussion on Model Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"*The small-angle approximation fails for large oscillations * *The model assumes a simple sinusoidal driving force. *","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Nonlinear Damping: More realistic energy dissipation models Non-Periodic Forcing: Studying real-world irregular driving forces. Coupled Pendulums: Exploring synchronization and complex dynamics.","title":"Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum provides insights into nonlinear dynamics, resonance, and chaos. By tuning parameters, we observe a transition from regular motion to chaos, revealing fundamental principles that apply to various fields of science and engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: Kepler's Third Law Motivation Kepler's Third Law, which states that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) , is a cornerstone of celestial mechanics. This relationship explains the motion of planets around the Sun, moons around planets, and satellites around Earth. It also provides a framework for calculating masses and distances in gravitational systems. This investigation explores the theoretical foundation, practical implications, and computational verification of Kepler's Third Law. Theoretical Foundation Derivation of Kepler's Third Law for Circular Orbits For a satellite of mass \\(m\\) orbiting a central body of mass \\(M\\) in a circular orbit of radius \\(r\\) , the gravitational force provides the centripetal force required for circular motion. Mathematically: \\(F_{\\text{gravity}}\\) = \\(F_{\\text{centripetal}}\\) \\(\\frac{GMm}{r^2}\\) = \\(\\frac{mv^2}{r}\\) Where: \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) \\(v\\) : Orbital velocity of the satellite \\(r\\) : Orbital radius \\(M\\) : Mass of the central body \\(m\\) : Mass of the orbiting body (cancels out in the equation) The orbital velocity \\(v\\) can be expressed in terms of the orbital period \\(TV\\) : \\[ v = \\frac{2\\pi r}{T} \\] Substituting \\(v\\) into the force equation: \\[ \\frac{GM}{r^2} = \\frac{(2\\pi r / T)^2}{r} \\] Simplifying: \\[ \\frac{GM}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Rearranging to solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] This is Kepler's Third Law for circular orbits, which states: \\[ T^2 \\propto r^3 \\] Implications for Astronomy Calculating Planetary Masses : By measuring the orbital period and radius of a moon or satellite, the mass of the central body (e.g., a planet) can be determined. Determining Distances : For planets in the Solar System, knowing the orbital period allows us to calculate their average distance from the Sun. Understanding Gravitational Systems : The law applies to binary star systems, exoplanets, and galaxies, providing insights into their structure and dynamics. Real-World Examples Moon's Orbit Around Earth : Orbital radius: \\(3.84 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(27.3 \\, \\text{days}\\) Using Kepler's Third Law, we can verify the relationship between \\(T^2\\) and \\(r^3\\) . Planets in the Solar System : For example, Earth's orbital radius ( \\(1 \\, \\text{AU}\\) ) and period ( \\(1 \\, \\text{year}\\) ) satisfy \\(T^2 \\propto r^3\\) . Computational Implementation Below is a Python implementation to simulate circular orbits and verify Kepler's Third Law. Python Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Orbital radii (in meters) r_values = np.linspace(6.371e6, 4e8, 100) # From Earth's surface to beyond the Moon's orbit # Calculate orbital periods T_values = orbital_period(r_values) # Plot T^2 vs. r^3 plt.figure(figsize=(10, 6)) plt.plot(r_values**3, T_values**2, 'b-', label=r'$T^2$ vs. $r^3$') plt.xlabel(r'$r^3$ (m$^3$)') plt.ylabel(r'$T^2$ (s$^2$)') plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$\") plt.grid() plt.legend() plt.show() # Simulate circular orbit def simulate_orbit(r, T, num_points=100): theta = np.linspace(0, 2 * np.pi, num_points) x = r * np.cos(theta) y = r * np.sin(theta) return x, y # Example: Earth's orbit (1 AU) r_earth = 1.496e11 # 1 AU in meters T_earth = 365.25 * 24 * 3600 # 1 year in seconds x, y = simulate_orbit(r_earth, T_earth) # Plot circular orbit plt.figure(figsize=(8, 8)) plt.plot(x, y, 'r-', label=\"Earth's Orbit\") plt.plot(0, 0, 'yo', label='Sun') # Sun at the center plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title(\"Circular Orbit Simulation\") plt.grid() plt.legend() plt.axis('equal') plt.show() Plots and Interpretations Kepler's Third Law Verification : The plot of \\((T^2)\\) vs. \\((r^3)\\) shows a linear relationship, confirming Kepler's Third Law. Explanation : The linearity of the graph demonstrates that \\((T^2)\\) is directly proportional to \\((r^3)\\) , as predicted by the law. Figure 1: Verification of Kepler's Third Law. Circular Orbit Simulation : The circular orbit of Earth around the Sun is visualized, demonstrating the application of the law. Explanation : The satellite follows a circular path around the central body, with the gravitational force providing the necessary centripetal force. Figure 2: Simulation of Earth's circular orbit around the Sun. Extensions to Elliptical Orbits Kepler's Third Law also applies to elliptical orbits, with the semi-major axis \\((a)\\) replacing the orbital radius \\((r)\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] This generalization allows the law to be applied to comets, asteroids, and other celestial bodies with non-circular orbits. Conclusion Kepler's Third Law provides a powerful tool for understanding orbital dynamics. By deriving and verifying the relationship between the square of the orbital period and the cube of the orbital radius, we gain insights into the motion of planets, moons, and satellites. This investigation bridges theoretical principles with real-world applications, highlighting the elegance and universality of gravitational physics. ```","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law, which states that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) , is a cornerstone of celestial mechanics. This relationship explains the motion of planets around the Sun, moons around planets, and satellites around Earth. It also provides a framework for calculating masses and distances in gravitational systems. This investigation explores the theoretical foundation, practical implications, and computational verification of Kepler's Third Law.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For a satellite of mass \\(m\\) orbiting a central body of mass \\(M\\) in a circular orbit of radius \\(r\\) , the gravitational force provides the centripetal force required for circular motion. Mathematically: \\(F_{\\text{gravity}}\\) = \\(F_{\\text{centripetal}}\\) \\(\\frac{GMm}{r^2}\\) = \\(\\frac{mv^2}{r}\\) Where: \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) \\(v\\) : Orbital velocity of the satellite \\(r\\) : Orbital radius \\(M\\) : Mass of the central body \\(m\\) : Mass of the orbiting body (cancels out in the equation) The orbital velocity \\(v\\) can be expressed in terms of the orbital period \\(TV\\) : \\[ v = \\frac{2\\pi r}{T} \\] Substituting \\(v\\) into the force equation: \\[ \\frac{GM}{r^2} = \\frac{(2\\pi r / T)^2}{r} \\] Simplifying: \\[ \\frac{GM}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Rearranging to solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] This is Kepler's Third Law for circular orbits, which states: \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-astronomy","text":"Calculating Planetary Masses : By measuring the orbital period and radius of a moon or satellite, the mass of the central body (e.g., a planet) can be determined. Determining Distances : For planets in the Solar System, knowing the orbital period allows us to calculate their average distance from the Sun. Understanding Gravitational Systems : The law applies to binary star systems, exoplanets, and galaxies, providing insights into their structure and dynamics.","title":"Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth : Orbital radius: \\(3.84 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(27.3 \\, \\text{days}\\) Using Kepler's Third Law, we can verify the relationship between \\(T^2\\) and \\(r^3\\) . Planets in the Solar System : For example, Earth's orbital radius ( \\(1 \\, \\text{AU}\\) ) and period ( \\(1 \\, \\text{year}\\) ) satisfy \\(T^2 \\propto r^3\\) .","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-implementation","text":"Below is a Python implementation to simulate circular orbits and verify Kepler's Third Law.","title":"Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Orbital radii (in meters) r_values = np.linspace(6.371e6, 4e8, 100) # From Earth's surface to beyond the Moon's orbit # Calculate orbital periods T_values = orbital_period(r_values) # Plot T^2 vs. r^3 plt.figure(figsize=(10, 6)) plt.plot(r_values**3, T_values**2, 'b-', label=r'$T^2$ vs. $r^3$') plt.xlabel(r'$r^3$ (m$^3$)') plt.ylabel(r'$T^2$ (s$^2$)') plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$\") plt.grid() plt.legend() plt.show() # Simulate circular orbit def simulate_orbit(r, T, num_points=100): theta = np.linspace(0, 2 * np.pi, num_points) x = r * np.cos(theta) y = r * np.sin(theta) return x, y # Example: Earth's orbit (1 AU) r_earth = 1.496e11 # 1 AU in meters T_earth = 365.25 * 24 * 3600 # 1 year in seconds x, y = simulate_orbit(r_earth, T_earth) # Plot circular orbit plt.figure(figsize=(8, 8)) plt.plot(x, y, 'r-', label=\"Earth's Orbit\") plt.plot(0, 0, 'yo', label='Sun') # Sun at the center plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title(\"Circular Orbit Simulation\") plt.grid() plt.legend() plt.axis('equal') plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plots-and-interpretations","text":"Kepler's Third Law Verification : The plot of \\((T^2)\\) vs. \\((r^3)\\) shows a linear relationship, confirming Kepler's Third Law. Explanation : The linearity of the graph demonstrates that \\((T^2)\\) is directly proportional to \\((r^3)\\) , as predicted by the law. Figure 1: Verification of Kepler's Third Law. Circular Orbit Simulation : The circular orbit of Earth around the Sun is visualized, demonstrating the application of the law. Explanation : The satellite follows a circular path around the central body, with the gravitational force providing the necessary centripetal force. Figure 2: Simulation of Earth's circular orbit around the Sun.","title":"Plots and Interpretations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions-to-elliptical-orbits","text":"Kepler's Third Law also applies to elliptical orbits, with the semi-major axis \\((a)\\) replacing the orbital radius \\((r)\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] This generalization allows the law to be applied to comets, asteroids, and other celestial bodies with non-circular orbits.","title":"Extensions to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a powerful tool for understanding orbital dynamics. By deriving and verifying the relationship between the square of the orbital period and the cube of the orbital radius, we gain insights into the motion of planets, moons, and satellites. This investigation bridges theoretical principles with real-world applications, highlighting the elegance and universality of gravitational physics. ```","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is an example of a system exhibiting complex behavior due to the interplay of damping, restoring forces, and external periodic driving forces. This simulation explores resonance, chaos, and quasiperiodic motion through numerical integration. Mathematical Model The motion of the forced damped pendulum is governed by the equation: \\(\\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\) where: \\(b\\) is the damping coefficient, \\(g\\) is the acceleration due to gravity, \\(L\\) is the length of the pendulum, \\(A\\) is the amplitude of the driving force, \\(\\omega\\) is the driving frequency. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2/3 # Driving frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dydt = [ omega_t, -b * omega_t - (g/L) * np.sin(theta) + A * np.cos(omega * t) ] return dydt # Time span t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Initial conditions y0 = [0.2, 0] # Initial angle and velocity # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Phase portrait plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.8) plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.grid() plt.show() # Poincare section (stroboscopic map) poincare_times = np.arange(0, 100, 2*np.pi/omega) poincare_points = [] for t_p in poincare_times: idx = (np.abs(sol.t - t_p)).argmin() poincare_points.append([sol.y[0][idx], sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(8, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='red') plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show() # Time series plot plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel(\"Time (s)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Time Evolution of Theta\") plt.legend() plt.grid() plt.show() # Bifurcation diagram A_values = np.linspace(0.5, 2.0, 20) th_values = [] for A in A_values: def system(t, y): return [y[1], -b * y[1] - (g/L) * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(system, t_span, y0, t_eval=t_eval, method='RK45') th_values.append(sol.y[0][-500:]) plt.figure(figsize=(8, 6)) for i, A in enumerate(A_values): plt.scatter([A] * len(th_values[i]), th_values[i], s=1, color='blue') plt.xlabel(\"Driving Force Amplitude (A)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Bifurcation Diagram\") plt.grid() plt.show() Results The simulation produces: Phase Portrait : Displays how the system evolves in phase space. Poincar\u00e9 Section : A stroboscopic map showing discrete points at specific time intervals, revealing periodic or chaotic behavior. Time Series Plot : Shows the evolution of the pendulum\u2019s angle over time. Bifurcation Diagram : Demonstrates the transition to chaos as the driving force amplitude increases. Conclusion The forced damped pendulum demonstrates a range of behaviors from simple oscillations to chaos, depending on parameter values. This study helps in understanding nonlinear dynamics in real-world systems like mechanical oscillators and electrical circuits.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The forced damped pendulum is an example of a system exhibiting complex behavior due to the interplay of damping, restoring forces, and external periodic driving forces. This simulation explores resonance, chaos, and quasiperiodic motion through numerical integration.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-model","text":"The motion of the forced damped pendulum is governed by the equation: \\(\\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\) where: \\(b\\) is the damping coefficient, \\(g\\) is the acceleration due to gravity, \\(L\\) is the length of the pendulum, \\(A\\) is the amplitude of the driving force, \\(\\omega\\) is the driving frequency.","title":"Mathematical Model"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2/3 # Driving frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dydt = [ omega_t, -b * omega_t - (g/L) * np.sin(theta) + A * np.cos(omega * t) ] return dydt # Time span t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Initial conditions y0 = [0.2, 0] # Initial angle and velocity # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Phase portrait plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.8) plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.grid() plt.show() # Poincare section (stroboscopic map) poincare_times = np.arange(0, 100, 2*np.pi/omega) poincare_points = [] for t_p in poincare_times: idx = (np.abs(sol.t - t_p)).argmin() poincare_points.append([sol.y[0][idx], sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(8, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='red') plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show() # Time series plot plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel(\"Time (s)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Time Evolution of Theta\") plt.legend() plt.grid() plt.show() # Bifurcation diagram A_values = np.linspace(0.5, 2.0, 20) th_values = [] for A in A_values: def system(t, y): return [y[1], -b * y[1] - (g/L) * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(system, t_span, y0, t_eval=t_eval, method='RK45') th_values.append(sol.y[0][-500:]) plt.figure(figsize=(8, 6)) for i, A in enumerate(A_values): plt.scatter([A] * len(th_values[i]), th_values[i], s=1, color='blue') plt.xlabel(\"Driving Force Amplitude (A)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Bifurcation Diagram\") plt.grid() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results","text":"The simulation produces: Phase Portrait : Displays how the system evolves in phase space. Poincar\u00e9 Section : A stroboscopic map showing discrete points at specific time intervals, revealing periodic or chaotic behavior. Time Series Plot : Shows the evolution of the pendulum\u2019s angle over time. Bifurcation Diagram : Demonstrates the transition to chaos as the driving force amplitude increases.","title":"Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"The forced damped pendulum demonstrates a range of behaviors from simple oscillations to chaos, depending on parameter values. This study helps in understanding nonlinear dynamics in real-world systems like mechanical oscillators and electrical circuits.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Theoretical Foundation The motion of the payload is governed by Newton's Law of Universal Gravitation: \\[F = G \\frac{M_E m}{r^2}\\] Where: \\(F\\) is the gravitational force \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N m}^2/\\text{kg}^2\\) ) \\(M_E\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ) \\(m\\) is the mass of the payload \\(r\\) is the distance between the payload and Earth's center The acceleration of the payload is: \\[a = \\frac{F}{m} = \\frac{G M_E}{r^2}\\] We can use numerical integration (e.g., Euler's method, Runge-Kutta) to solve the equations of motion and determine the trajectory. Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 ME = 5.972e24 RE = 6.371e6 # Earth's radius def gravity(r): return -G * ME / np.linalg.norm(r)**3 * r def simulate_trajectory(r0, v0, dt, duration): num_steps = int(duration / dt) r = np.zeros((num_steps, 2)) v = np.zeros((num_steps, 2)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): a = gravity(r[i-1]) v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r # Example 1: Elliptical Orbit r0_ellipse = np.array([RE + 400e3, 0.0]) v0_ellipse = np.array([0.0, 7.5e3]) dt = 10 duration = 8000 r_ellipse = simulate_trajectory(r0_ellipse, v0_ellipse, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_ellipse[:, 0], r_ellipse[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Elliptical Orbit\") plt.axis('equal') plt.grid(True) plt.savefig('elliptical_orbit.png') plt.show() # Example 2: Escape Trajectory r0_escape = np.array([RE + 200e3, 0.0]) v0_escape = np.array([0.0, 11.5e3]) r_escape = simulate_trajectory(r0_escape, v0_escape, dt, duration*3) plt.figure(figsize=(8, 8)) plt.plot(r_escape[:, 0], r_escape[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Escape Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('escape_trajectory.png') plt.show() # Example 3: Re-entry Trajectory r0_reentry = np.array([RE + 500e3, 0.0]) v0_reentry = np.array([0.0, -7.0e3]) r_reentry = simulate_trajectory(r0_reentry, v0_reentry, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_reentry[:, 0], r_reentry[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Re-entry Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('reentry_trajectory.png') plt.show() # Example 4: Parabolic Trajectory (Escape Velocity) r0_parabolic = np.array([RE + 300e3, 0.0]) v0_parabolic = np.array([0.0, np.sqrt(2 * G * ME / (RE + 300e3))]) # escape velocity r_parabolic = simulate_trajectory(r0_parabolic, v0_parabolic, dt, duration*2) plt.figure(figsize=(8, 8)) plt.plot(r_parabolic[:, 0], r_parabolic[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Parabolic Trajectory (Escape)\") plt.axis('equal') plt.grid(True) plt.savefig('parabolic_trajectory.png') plt.show() Graphical Representations Discussion Elliptical Orbits: When the initial velocity is less than the escape velocity, and the trajectory does not intersect the Earth's surface, the payload will follow an elliptical orbit. Escape Trajectories: If the initial velocity is greater than the escape velocity, the payload will follow a hyperbolic trajectory and escape Earth's gravitational pull. Re-entry Trajectories: If the initial velocity is directed towards Earth, the payload will follow a trajectory that intersects Earth's surface, resulting in re-entry. Parabolic Trajectory: When the velocity equals the escape velocity, the trajectory will be parabolic. These examples illustrate how initial conditions significantly impact the payload's trajectory, which is crucial for space mission planning, satellite deployment, and understanding celestial mechanics. Conclusion This analysis and simulation demonstrate the complex interplay between initial conditions and gravitational forces that determine a payload's trajectory near Earth. Numerical methods allow us to visualize and analyze these trajectories, providing valuable insights for various space-related applications. ```","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"The motion of the payload is governed by Newton's Law of Universal Gravitation: \\[F = G \\frac{M_E m}{r^2}\\] Where: \\(F\\) is the gravitational force \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N m}^2/\\text{kg}^2\\) ) \\(M_E\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ) \\(m\\) is the mass of the payload \\(r\\) is the distance between the payload and Earth's center The acceleration of the payload is: \\[a = \\frac{F}{m} = \\frac{G M_E}{r^2}\\] We can use numerical integration (e.g., Euler's method, Runge-Kutta) to solve the equations of motion and determine the trajectory.","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 ME = 5.972e24 RE = 6.371e6 # Earth's radius def gravity(r): return -G * ME / np.linalg.norm(r)**3 * r def simulate_trajectory(r0, v0, dt, duration): num_steps = int(duration / dt) r = np.zeros((num_steps, 2)) v = np.zeros((num_steps, 2)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): a = gravity(r[i-1]) v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r # Example 1: Elliptical Orbit r0_ellipse = np.array([RE + 400e3, 0.0]) v0_ellipse = np.array([0.0, 7.5e3]) dt = 10 duration = 8000 r_ellipse = simulate_trajectory(r0_ellipse, v0_ellipse, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_ellipse[:, 0], r_ellipse[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Elliptical Orbit\") plt.axis('equal') plt.grid(True) plt.savefig('elliptical_orbit.png') plt.show() # Example 2: Escape Trajectory r0_escape = np.array([RE + 200e3, 0.0]) v0_escape = np.array([0.0, 11.5e3]) r_escape = simulate_trajectory(r0_escape, v0_escape, dt, duration*3) plt.figure(figsize=(8, 8)) plt.plot(r_escape[:, 0], r_escape[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Escape Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('escape_trajectory.png') plt.show() # Example 3: Re-entry Trajectory r0_reentry = np.array([RE + 500e3, 0.0]) v0_reentry = np.array([0.0, -7.0e3]) r_reentry = simulate_trajectory(r0_reentry, v0_reentry, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_reentry[:, 0], r_reentry[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Re-entry Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('reentry_trajectory.png') plt.show() # Example 4: Parabolic Trajectory (Escape Velocity) r0_parabolic = np.array([RE + 300e3, 0.0]) v0_parabolic = np.array([0.0, np.sqrt(2 * G * ME / (RE + 300e3))]) # escape velocity r_parabolic = simulate_trajectory(r0_parabolic, v0_parabolic, dt, duration*2) plt.figure(figsize=(8, 8)) plt.plot(r_parabolic[:, 0], r_parabolic[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Parabolic Trajectory (Escape)\") plt.axis('equal') plt.grid(True) plt.savefig('parabolic_trajectory.png') plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representations","text":"","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"Elliptical Orbits: When the initial velocity is less than the escape velocity, and the trajectory does not intersect the Earth's surface, the payload will follow an elliptical orbit. Escape Trajectories: If the initial velocity is greater than the escape velocity, the payload will follow a hyperbolic trajectory and escape Earth's gravitational pull. Re-entry Trajectories: If the initial velocity is directed towards Earth, the payload will follow a trajectory that intersects Earth's surface, resulting in re-entry. Parabolic Trajectory: When the velocity equals the escape velocity, the trajectory will be parabolic. These examples illustrate how initial conditions significantly impact the payload's trajectory, which is crucial for space mission planning, satellite deployment, and understanding celestial mechanics.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"This analysis and simulation demonstrate the complex interplay between initial conditions and gravitational forces that determine a payload's trajectory near Earth. Numerical methods allow us to visualize and analyze these trajectories, providing valuable insights for various space-related applications. ```","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface from Multiple Point Sources Motivation Interference patterns on a water surface provide an intuitive visualization of wave superposition. By analyzing the interaction of waves emanating from multiple point sources arranged in regular polygon configurations, we can explore the intricate dynamics of wave phenomena, including constructive and destructive interference. This study aims to deepen our understanding of wave behavior through simulation and visualization. Task Analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of various regular polygons. Theoretical Foundation The displacement of a circular wave on a water surface from a point source at \\((x_0, y_0)\\) is given by: \\[\\eta(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi)\\] Where: \\(\\eta(x, y, t)\\) is the displacement at \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number. \\(\\omega = 2\\pi f\\) is the angular frequency. \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source. \\(\\phi\\) is the initial phase. The superposition of waves from \\(N\\) sources is: \\[\\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t)\\] Python Simulation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation def wave_displacement(x, y, x0, y0, A, k, omega, t, phi): r = np.sqrt((x - x0)**2 + (y - y0)**2) return A * np.cos(k * r - omega * t + phi) def superposition(x, y, sources, A, k, omega, t, phi): total_displacement = np.zeros_like(x) for x0, y0 in sources: total_displacement += wave_displacement(x, y, x0, y0, A, k, omega, t, phi) return total_displacement def generate_sources(n, radius): theta = np.linspace(0, 2 * np.pi, n, endpoint=False) return [(radius * np.cos(t), radius * np.sin(t)) for t in theta] def visualize_interference(sources, A, wavelength, frequency, duration, frames, filename): k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t_values = np.linspace(0, duration, frames) x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(8, 8)) img = ax.imshow(superposition(X, Y, sources, A, k, omega, 0, phi), cmap='viridis', extent=[-3, 3, -3, 3], animated=True) def update(frame): img.set_array(superposition(X, Y, sources, A, k, omega, t_values[frame], phi)) return img, ani = animation.FuncAnimation(fig, update, frames=frames, blit=True) ani.save(filename, writer='pillow', fps=10) plt.close() # Parameters A = 1 wavelength = 1 frequency = 1 duration = 10 frames = 100 # Examples # Triangle triangle_sources = generate_sources(3, 1) visualize_interference(triangle_sources, A, wavelength, frequency, duration, frames, 'triangle_interference.gif') print(\"Triangle interference animation generated.\") # Square square_sources = generate_sources(4, 1) visualize_interference(square_sources, A, wavelength, frequency, duration, frames, 'square_interference.gif') print(\"Square interference animation generated.\") # Pentagon pentagon_sources = generate_sources(5, 1) visualize_interference(pentagon_sources, A, wavelength, frequency, duration, frames, 'pentagon_interference.gif') print(\"Pentagon interference animation generated.\") # Hexagon hexagon_sources = generate_sources(6, 1) visualize_interference(hexagon_sources, A, wavelength, frequency, duration, frames, 'hexagon_interference.gif') print(\"Hexagon interference animation generated.\") # Octagon octagon_sources = generate_sources(8, 1) visualize_interference(octagon_sources, A, wavelength, frequency, duration, frames, 'octagon_interference.gif') print(\"Octagon interference animation generated.\") # Circle (Approximation) circle_sources = generate_sources(30, 1) visualize_interference(circle_sources, A, wavelength, frequency, duration, frames, 'circle_interference.gif') print(\"Circle interference animation generated.\") Graphical Representations Triangle Interference Pattern \u2013 Wave interference from 3 point sources. Square Interference Pattern \u2013 Wave interference from 4 point sources. Pentagon Interference Pattern \u2013 Wave interference from 5 point sources. Octagon Interference Pattern \u2013 Wave interference from 8 point sources. Circular Interference Approximation \u2013 Wave interference from 30 point sources. Analysis Constructive Interference: Occurs where waves align in phase, resulting in increased amplitude. In our visualizations, these regions are bright. Destructive Interference: Occurs where waves align out of phase, resulting in decreased or zero amplitude. These regions are dark. Regular Polygons: The number of sources and their arrangement directly influence the complexity of the interference patterns. Higher numbers of sources result in more intricate patterns. Circular Approximation: As the number of sources increases, the polygon approaches a circle, resulting in a more uniform and detailed interference pattern. Animation: The animations illustrate the dynamic nature of interference patterns, showing how they evolve over time. Conclusion This study demonstrates the complex interference patterns that emerge from multiple point sources arranged in regular polygons. By visualizing these patterns, we gain a deeper understanding of wave superposition and its dependence on source geometry. This analysis offers a practical approach to exploring wave phenomena and their applications in various fields.","title":"Interference Patterns on a Water Surface from Multiple Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface-from-multiple-point-sources","text":"","title":"Interference Patterns on a Water Surface from Multiple Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns on a water surface provide an intuitive visualization of wave superposition. By analyzing the interaction of waves emanating from multiple point sources arranged in regular polygon configurations, we can explore the intricate dynamics of wave phenomena, including constructive and destructive interference. This study aims to deepen our understanding of wave behavior through simulation and visualization.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of various regular polygons.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"The displacement of a circular wave on a water surface from a point source at \\((x_0, y_0)\\) is given by: \\[\\eta(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi)\\] Where: \\(\\eta(x, y, t)\\) is the displacement at \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number. \\(\\omega = 2\\pi f\\) is the angular frequency. \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source. \\(\\phi\\) is the initial phase. The superposition of waves from \\(N\\) sources is: \\[\\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t)\\]","title":"Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation def wave_displacement(x, y, x0, y0, A, k, omega, t, phi): r = np.sqrt((x - x0)**2 + (y - y0)**2) return A * np.cos(k * r - omega * t + phi) def superposition(x, y, sources, A, k, omega, t, phi): total_displacement = np.zeros_like(x) for x0, y0 in sources: total_displacement += wave_displacement(x, y, x0, y0, A, k, omega, t, phi) return total_displacement def generate_sources(n, radius): theta = np.linspace(0, 2 * np.pi, n, endpoint=False) return [(radius * np.cos(t), radius * np.sin(t)) for t in theta] def visualize_interference(sources, A, wavelength, frequency, duration, frames, filename): k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t_values = np.linspace(0, duration, frames) x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(8, 8)) img = ax.imshow(superposition(X, Y, sources, A, k, omega, 0, phi), cmap='viridis', extent=[-3, 3, -3, 3], animated=True) def update(frame): img.set_array(superposition(X, Y, sources, A, k, omega, t_values[frame], phi)) return img, ani = animation.FuncAnimation(fig, update, frames=frames, blit=True) ani.save(filename, writer='pillow', fps=10) plt.close() # Parameters A = 1 wavelength = 1 frequency = 1 duration = 10 frames = 100 # Examples # Triangle triangle_sources = generate_sources(3, 1) visualize_interference(triangle_sources, A, wavelength, frequency, duration, frames, 'triangle_interference.gif') print(\"Triangle interference animation generated.\") # Square square_sources = generate_sources(4, 1) visualize_interference(square_sources, A, wavelength, frequency, duration, frames, 'square_interference.gif') print(\"Square interference animation generated.\") # Pentagon pentagon_sources = generate_sources(5, 1) visualize_interference(pentagon_sources, A, wavelength, frequency, duration, frames, 'pentagon_interference.gif') print(\"Pentagon interference animation generated.\") # Hexagon hexagon_sources = generate_sources(6, 1) visualize_interference(hexagon_sources, A, wavelength, frequency, duration, frames, 'hexagon_interference.gif') print(\"Hexagon interference animation generated.\") # Octagon octagon_sources = generate_sources(8, 1) visualize_interference(octagon_sources, A, wavelength, frequency, duration, frames, 'octagon_interference.gif') print(\"Octagon interference animation generated.\") # Circle (Approximation) circle_sources = generate_sources(30, 1) visualize_interference(circle_sources, A, wavelength, frequency, duration, frames, 'circle_interference.gif') print(\"Circle interference animation generated.\")","title":"Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#graphical-representations","text":"Triangle Interference Pattern \u2013 Wave interference from 3 point sources. Square Interference Pattern \u2013 Wave interference from 4 point sources. Pentagon Interference Pattern \u2013 Wave interference from 5 point sources. Octagon Interference Pattern \u2013 Wave interference from 8 point sources. Circular Interference Approximation \u2013 Wave interference from 30 point sources.","title":"Graphical Representations"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis","text":"Constructive Interference: Occurs where waves align in phase, resulting in increased amplitude. In our visualizations, these regions are bright. Destructive Interference: Occurs where waves align out of phase, resulting in decreased or zero amplitude. These regions are dark. Regular Polygons: The number of sources and their arrangement directly influence the complexity of the interference patterns. Higher numbers of sources result in more intricate patterns. Circular Approximation: As the number of sources increases, the polygon approaches a circle, resulting in a more uniform and detailed interference pattern. Animation: The animations illustrate the dynamic nature of interference patterns, showing how they evolve over time.","title":"Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This study demonstrates the complex interference patterns that emerge from multiple point sources arranged in regular polygons. By visualizing these patterns, we gain a deeper understanding of wave superposition and its dependence on source geometry. This analysis offers a practical approach to exploring wave phenomena and their applications in various fields.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism: Lorentz Force Simulation Problem 1 \u2013 Simulating the Effects of the Lorentz Force Motivation The Lorentz force governs the motion of charged particles in electromagnetic fields and is given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This force is fundamental to understanding plasma physics, mass spectrometry, particle accelerators, and astrophysical phenomena. Through simulations, we can explore the effects of different electric and magnetic field configurations on a particle's trajectory. 1. Exploration of Applications Particle Accelerators : Use magnetic fields to steer and focus particle beams. Mass Spectrometers : Separate ions by mass-to-charge ratio using electric and magnetic fields. Plasma Confinement : Magnetic fields contain high-temperature plasma in fusion reactors. Cyclotrons : Accelerate particles in spiral paths due to the Lorentz force. Electric fields influence speed; magnetic fields influence direction. Together, they enable precision control of charged particles. 2. Simulation of Particle Motion Imports and Setup import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial conditions q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step (s) steps = 2000 # Number of simulation steps # Initial velocity and position v0 = np.array([1.0, 0.0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) Lorentz Force Function def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) Runge-Kutta 4 Integrator def rk4_lorentz(v0, r0, E, B): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(steps - 1): k1v = dt * lorentz_force(v[i], E, B) / m k1r = dt * v[i] k2v = dt * lorentz_force(v[i] + 0.5 * k1v, E, B) / m k2r = dt * (v[i] + 0.5 * k1v) k3v = dt * lorentz_force(v[i] + 0.5 * k2v, E, B) / m k3r = dt * (v[i] + 0.5 * k2v) k4v = dt * lorentz_force(v[i] + k3v, E, B) / m k4r = dt * (v[i] + k3v) v[i+1] = v[i] + (k1v + 2*k2v + 2*k3v + k4v) / 6 r[i+1] = r[i] + (k1r + 2*k2r + 2*k3r + k4r) / 6 return r, v Field Configurations # Case 1: Uniform magnetic field (circular/spiral motion) E1 = np.array([0.0, 0.0, 0.0]) B1 = np.array([0.0, 0.0, 1.0]) # Case 2: Uniform E and B fields (helical + drift) E2 = np.array([0.0, 1.0, 0.0]) B2 = np.array([0.0, 0.0, 1.0]) # Case 3: Crossed E and B fields (ExB drift) E3 = np.array([1.0, 0.0, 0.0]) B3 = np.array([0.0, 0.0, 1.0]) 3. Visualization def plot_trajectory(r, title=\"Trajectory\"): fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], lw=2) ax.set_title(title) ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") plt.show() Run and Plot Simulations r1, _ = rk4_lorentz(v0, r0, E1, B1) plot_trajectory(r1, \"Circular/Helical Motion (B only)\") r2, _ = rk4_lorentz(v0, r0, E2, B2) plot_trajectory(r2, \"Helical Motion with Drift (E and B)\") r3, _ = rk4_lorentz(v0, r0, E3, B3) plot_trajectory(r3, \"ExB Drift (Crossed Fields)\") 4. Parameter Exploration Try modifying: - q , m : Charge and mass - v0 : Initial velocity - E , B : Field vectors Observe: - Larmor radius : $ r_L = \\frac{mv_\\perp}{qB} $ - Cyclotron frequency : $ \\omega_c = \\frac{qB}{m} $ - ExB drift velocity : $ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $ 5. Discussion and Applications Cyclotrons rely on the circular motion from a perpendicular $ \\vec{v} $ and $ \\vec{B} $. Magnetic Traps (e.g., tokamaks) confine particles using helical paths. Mass Spectrometers utilize radius dependence on mass-to-charge ratio. Space Physics : Charged particles spiral along magnetic field lines of Earth. 6. Extensions Include non-uniform fields (e.g., magnetic mirrors). Add collisions or frictional forces . Simulate multiple particles (plasmas, beam dynamics). Note: All simulations use the RK4 method for accuracy. Be sure to adjust steps and dt based on scenario dynamics. ``` Let me know if you'd like a .ipynb version or want to add interactive sliders (e.g., using ipywidgets ) for field strength, charge, or mass.","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1 \u2013 Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in electromagnetic fields and is given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This force is fundamental to understanding plasma physics, mass spectrometry, particle accelerators, and astrophysical phenomena. Through simulations, we can explore the effects of different electric and magnetic field configurations on a particle's trajectory.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Particle Accelerators : Use magnetic fields to steer and focus particle beams. Mass Spectrometers : Separate ions by mass-to-charge ratio using electric and magnetic fields. Plasma Confinement : Magnetic fields contain high-temperature plasma in fusion reactors. Cyclotrons : Accelerate particles in spiral paths due to the Lorentz force. Electric fields influence speed; magnetic fields influence direction. Together, they enable precision control of charged particles.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulation-of-particle-motion","text":"","title":"2. Simulation of Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#imports-and-setup","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial conditions q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step (s) steps = 2000 # Number of simulation steps # Initial velocity and position v0 = np.array([1.0, 0.0, 1.0]) r0 = np.array([0.0, 0.0, 0.0])","title":"Imports and Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-function","text":"def lorentz_force(v, E, B): return q * (E + np.cross(v, B))","title":"Lorentz Force Function"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#runge-kutta-4-integrator","text":"def rk4_lorentz(v0, r0, E, B): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(steps - 1): k1v = dt * lorentz_force(v[i], E, B) / m k1r = dt * v[i] k2v = dt * lorentz_force(v[i] + 0.5 * k1v, E, B) / m k2r = dt * (v[i] + 0.5 * k1v) k3v = dt * lorentz_force(v[i] + 0.5 * k2v, E, B) / m k3r = dt * (v[i] + 0.5 * k2v) k4v = dt * lorentz_force(v[i] + k3v, E, B) / m k4r = dt * (v[i] + k3v) v[i+1] = v[i] + (k1v + 2*k2v + 2*k3v + k4v) / 6 r[i+1] = r[i] + (k1r + 2*k2r + 2*k3r + k4r) / 6 return r, v","title":"Runge-Kutta 4 Integrator"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#field-configurations","text":"# Case 1: Uniform magnetic field (circular/spiral motion) E1 = np.array([0.0, 0.0, 0.0]) B1 = np.array([0.0, 0.0, 1.0]) # Case 2: Uniform E and B fields (helical + drift) E2 = np.array([0.0, 1.0, 0.0]) B2 = np.array([0.0, 0.0, 1.0]) # Case 3: Crossed E and B fields (ExB drift) E3 = np.array([1.0, 0.0, 0.0]) B3 = np.array([0.0, 0.0, 1.0])","title":"Field Configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-visualization","text":"def plot_trajectory(r, title=\"Trajectory\"): fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], lw=2) ax.set_title(title) ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") plt.show()","title":"3. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#run-and-plot-simulations","text":"r1, _ = rk4_lorentz(v0, r0, E1, B1) plot_trajectory(r1, \"Circular/Helical Motion (B only)\") r2, _ = rk4_lorentz(v0, r0, E2, B2) plot_trajectory(r2, \"Helical Motion with Drift (E and B)\") r3, _ = rk4_lorentz(v0, r0, E3, B3) plot_trajectory(r3, \"ExB Drift (Crossed Fields)\")","title":"Run and Plot Simulations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"Try modifying: - q , m : Charge and mass - v0 : Initial velocity - E , B : Field vectors Observe: - Larmor radius : $ r_L = \\frac{mv_\\perp}{qB} $ - Cyclotron frequency : $ \\omega_c = \\frac{qB}{m} $ - ExB drift velocity : $ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-discussion-and-applications","text":"Cyclotrons rely on the circular motion from a perpendicular $ \\vec{v} $ and $ \\vec{B} $. Magnetic Traps (e.g., tokamaks) confine particles using helical paths. Mass Spectrometers utilize radius dependence on mass-to-charge ratio. Space Physics : Charged particles spiral along magnetic field lines of Earth.","title":"5. Discussion and Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-extensions","text":"Include non-uniform fields (e.g., magnetic mirrors). Add collisions or frictional forces . Simulate multiple particles (plasmas, beam dynamics). Note: All simulations use the RK4 method for accuracy. Be sure to adjust steps and dt based on scenario dynamics. ``` Let me know if you'd like a .ipynb version or want to add interactive sliders (e.g., using ipywidgets ) for field strength, charge, or mass.","title":"6. Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Introduction Calculating equivalent resistance is a fundamental problem in circuit analysis. Traditional methods involve applying series and parallel resistance formulas iteratively. However, for complex circuits, graph theory provides a more systematic approach by representing circuits as weighted graphs. In this document, we explore how to calculate equivalent resistance using graph theory, implement it programmatically, and visualize the circuit as a graph. Graph Representation of Circuits A circuit can be represented as an undirected graph: - Nodes (Vertices) : Represent junctions in the circuit. - Edges : Represent resistors, with weights corresponding to resistance values. Graph simplification involves: - Identifying series and parallel resistor connections. - Using algorithmic techniques to iteratively reduce the graph. Theoretical Background Series Resistance For resistors in series, the equivalent resistance is: $$ R_{eq} = R_1 + R_2 + \\dots + R_n $$ Parallel Resistance For resistors in parallel, the equivalent resistance is given by: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} $$ Graph Reduction Approach Identify series and parallel components in the circuit graph. Reduce series and parallel resistors iteratively. Continue simplification until a single equivalent resistance remains. Python Implementation The following Python script models a circuit as a graph and calculates the equivalent resistance. import networkx as nx import matplotlib.pyplot as plt def calculate_resistance(graph, start, end): paths = list(nx.all_simple_paths(graph, source=start, target=end)) parallel_resistances = [] for path in paths: series_resistance = sum(graph[path[i]][path[i+1]]['weight'] for i in range(len(path)-1)) parallel_resistances.append(1 / series_resistance) return 1 / sum(parallel_resistances) def visualize_circuit(graph): pos = nx.spring_layout(graph) labels = nx.get_edge_attributes(graph, 'weight') nx.draw(graph, pos, with_labels=True, node_color='lightblue', edge_color='black') nx.draw_networkx_edge_labels(graph, pos, edge_labels=labels) plt.title(\"Circuit Representation\") plt.show() # Create a sample circuit graph = nx.Graph() graph.add_edge('A', 'B', weight=5) graph.add_edge('B', 'C', weight=10) graph.add_edge('A', 'C', weight=15) # Parallel path visualize_circuit(graph) print(\"Equivalent Resistance:\", calculate_resistance(graph, 'A', 'C')) Example Circuits and Graphs Example 1: Simple Series Circuit Resistors: \\(5\u03a9\\) , \\(10\u03a9\\) , \\(15\u03a9\\) in series. Graph Representation: A --- 5\u03a9 --- B --- 10\u03a9 --- C --- 15\u03a9 --- D Equivalent Resistance: $$ R_{eq} = 5 + 10 + 15 = 30\u03a9 $$ Example 2: Parallel Circuit Resistors: \\(5\u03a9\\) , \\(10\u03a9\\) in parallel. Graph Representation: A | \\ | 5\u03a9 \\ | \\ | B | / | 10\u03a9 / | / C Equivalent Resistance: $$ \\frac{1}{R_{eq}} = \\frac{1}{5} + \\frac{1}{10} \\Rightarrow R_{eq} = 3.33\u03a9 $$ Conclusion By leveraging graph theory, we can systematically compute the equivalent resistance of complex circuits. This method is efficient for large networks and allows for automation in electrical circuit simulations. Further Exploration Extend the algorithm to handle more complex circuit configurations. Integrate Kirchhoff\u2019s laws to analyze voltage and current distributions. Implement a graphical user interface (GUI) for interactive circuit analysis. References Network Analysis by M.E. Van Valkenburg Graph Theory Applications in Electrical Engineering","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating equivalent resistance is a fundamental problem in circuit analysis. Traditional methods involve applying series and parallel resistance formulas iteratively. However, for complex circuits, graph theory provides a more systematic approach by representing circuits as weighted graphs. In this document, we explore how to calculate equivalent resistance using graph theory, implement it programmatically, and visualize the circuit as a graph.","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation-of-circuits","text":"A circuit can be represented as an undirected graph: - Nodes (Vertices) : Represent junctions in the circuit. - Edges : Represent resistors, with weights corresponding to resistance values. Graph simplification involves: - Identifying series and parallel resistor connections. - Using algorithmic techniques to iteratively reduce the graph.","title":"Graph Representation of Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-resistance","text":"For resistors in series, the equivalent resistance is: $$ R_{eq} = R_1 + R_2 + \\dots + R_n $$","title":"Series Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistance","text":"For resistors in parallel, the equivalent resistance is given by: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} $$","title":"Parallel Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-reduction-approach","text":"Identify series and parallel components in the circuit graph. Reduce series and parallel resistors iteratively. Continue simplification until a single equivalent resistance remains.","title":"Graph Reduction Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"The following Python script models a circuit as a graph and calculates the equivalent resistance. import networkx as nx import matplotlib.pyplot as plt def calculate_resistance(graph, start, end): paths = list(nx.all_simple_paths(graph, source=start, target=end)) parallel_resistances = [] for path in paths: series_resistance = sum(graph[path[i]][path[i+1]]['weight'] for i in range(len(path)-1)) parallel_resistances.append(1 / series_resistance) return 1 / sum(parallel_resistances) def visualize_circuit(graph): pos = nx.spring_layout(graph) labels = nx.get_edge_attributes(graph, 'weight') nx.draw(graph, pos, with_labels=True, node_color='lightblue', edge_color='black') nx.draw_networkx_edge_labels(graph, pos, edge_labels=labels) plt.title(\"Circuit Representation\") plt.show() # Create a sample circuit graph = nx.Graph() graph.add_edge('A', 'B', weight=5) graph.add_edge('B', 'C', weight=10) graph.add_edge('A', 'C', weight=15) # Parallel path visualize_circuit(graph) print(\"Equivalent Resistance:\", calculate_resistance(graph, 'A', 'C'))","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-circuits-and-graphs","text":"","title":"Example Circuits and Graphs"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series-circuit","text":"Resistors: \\(5\u03a9\\) , \\(10\u03a9\\) , \\(15\u03a9\\) in series. Graph Representation: A --- 5\u03a9 --- B --- 10\u03a9 --- C --- 15\u03a9 --- D Equivalent Resistance: $$ R_{eq} = 5 + 10 + 15 = 30\u03a9 $$","title":"Example 1: Simple Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel-circuit","text":"Resistors: \\(5\u03a9\\) , \\(10\u03a9\\) in parallel. Graph Representation: A | \\ | 5\u03a9 \\ | \\ | B | / | 10\u03a9 / | / C Equivalent Resistance: $$ \\frac{1}{R_{eq}} = \\frac{1}{5} + \\frac{1}{10} \\Rightarrow R_{eq} = 3.33\u03a9 $$","title":"Example 2: Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"By leveraging graph theory, we can systematically compute the equivalent resistance of complex circuits. This method is efficient for large networks and allows for automation in electrical circuit simulations.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/#further-exploration","text":"Extend the algorithm to handle more complex circuit configurations. Integrate Kirchhoff\u2019s laws to analyze voltage and current distributions. Implement a graphical user interface (GUI) for interactive circuit analysis.","title":"Further Exploration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#references","text":"Network Analysis by M.E. Van Valkenburg Graph Theory Applications in Electrical Engineering","title":"References"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}