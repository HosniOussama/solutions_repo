{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The goal is to analyze how the range of a projectile depends on its angle of projection . Despite its simplicity, this system unveils deep physical insights through linear and quadratic relationships. Parameters like initial velocity , gravitational acceleration , and launch height influence the trajectory, allowing us to model diverse real-world phenomena\u2014from sports to rocketry. 1. Theoretical Foundation Equations of Motion We consider a projectile launched from ground level (height = 0) with: - Initial velocity \\(( v_0 )\\) - Angle of projection \\(( \\theta )\\) - Gravitational acceleration \\(( g )\\) The horizontal and vertical components of velocity: \\[ v_{x} = v_0 \\cos(\\theta), \\quad v_{y} = v_0 \\sin(\\theta) \\] Time of flight (until the projectile returns to \\(y\\) = 0): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Horizontal Range: \\[ R(\\theta) = v_{x} \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation reveals a sinusoidal dependence of range on $ 2\\theta $. The maximum range occurs when $ \\theta = 45^\\circ $. 2. Analysis of the Range vs Angle Python Code: Plotting the Range as a Function of Angle import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s\u00b2 # Angles from 0 to 90 degrees angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) # Range formula: R = (v0^2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, color='blue') plt.title(\"Projectile Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.legend() plt.show() Observations: The range reaches its maximum at 45\u00b0. Complementary angles (e.g., 30\u00b0 and 60\u00b0) yield the same range. The curve is symmetric around 45\u00b0. 3. Influence of Parameters And with appying modifications on $ v_0 $ \\(g\\) this is how can affect the plot Python Code import numpy as np import matplotlib.pyplot as plt # Common parameters angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) # ========== Effect of Initial Velocity ========== v0_values = [20, 30, 40] # initial velocities in m/s g = 9.81 # gravitational acceleration (Earth) plt.figure(figsize=(10, 6)) for v0 in v0_values: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, ranges, label=f'v\u2080 = {v0} m/s') plt.title(\"Effect of Initial Velocity on Range\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # ========== Effect of Gravity ========== g_values = [9.81, 1.62] # Earth and Moon gravity v0_fixed = 30 # fixed initial velocity plt.figure(figsize=(10, 6)) for g in g_values: ranges = (v0_fixed**2 * np.sin(2 * angles_rad)) / g label = f'g = {g} m/s\u00b2 ({\"Earth\" if g==9.81 else \"Moon\"})' plt.plot(angles_deg, ranges, label=label) plt.title(\"Effect of Gravity on Range\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Key Takeaways: Higher velocity = longer range. Lower gravity (e.g., Moon) = much longer range. 4. Practical Applications Real-World Adjustments Uneven terrain affects landing point \u2192 adjust final height. Air resistance shortens range \u2192 not covered in ideal model. Wind adds horizontal forces \u2192 requires differential equations. Example: Adding a Launch Height Python Code --- ```python def range_with_height(v0, theta_deg, h, g=9.81): theta = np.radians(theta_deg) vx = v0 * np.cos(theta) vy = v0 * np.sin(theta) t_flight = (vy + np.sqrt(vy**2 + 2 * g * h)) / g return vx * t_flight h = 10 # 10 meters launch height ranges = [range_with_height(30, angle, h) for angle in angles_deg] plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges) plt.title(\"Range vs Angle (with Launch Height h = 10 m)\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.show() Insights: Maximum range shifts to lower than 45\u00b0 if starting from a height. Launch height increases overall range. 5. Limitations of the Idealized Model Assumption Real-World Factor Impact No air resistance Drag force Reduces range Constant gravity Varies with altitude Small effect in most cases Flat terrain Hills or valleys Changes point of impact No wind Wind can push/pull projectile Alters horizontal motion Suggestions for Improvement Use scipy.integrate.solve_ivp to include air drag. Use parametric terrain modeling for variable height. Apply wind forces using vector additions in numerical simulation. Conclusion Projectile range depends heavily on angle , initial speed , and gravitational field . The theoretical model, while idealized, provides great insight and a foundation for more complex simulations. With simple Python tools, we can visualize and analyze this behavior effectively\u2014bridging the gap between theory and practice.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The goal is to analyze how the range of a projectile depends on its angle of projection . Despite its simplicity, this system unveils deep physical insights through linear and quadratic relationships. Parameters like initial velocity , gravitational acceleration , and launch height influence the trajectory, allowing us to model diverse real-world phenomena\u2014from sports to rocketry.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"We consider a projectile launched from ground level (height = 0) with: - Initial velocity \\(( v_0 )\\) - Angle of projection \\(( \\theta )\\) - Gravitational acceleration \\(( g )\\) The horizontal and vertical components of velocity: \\[ v_{x} = v_0 \\cos(\\theta), \\quad v_{y} = v_0 \\sin(\\theta) \\] Time of flight (until the projectile returns to \\(y\\) = 0): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Horizontal Range: \\[ R(\\theta) = v_{x} \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation reveals a sinusoidal dependence of range on $ 2\\theta $. The maximum range occurs when $ \\theta = 45^\\circ $.","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range-vs-angle","text":"","title":"2. Analysis of the Range vs Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-plotting-the-range-as-a-function-of-angle","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s\u00b2 # Angles from 0 to 90 degrees angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) # Range formula: R = (v0^2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, color='blue') plt.title(\"Projectile Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.legend() plt.show()","title":"Python Code: Plotting the Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range reaches its maximum at 45\u00b0. Complementary angles (e.g., 30\u00b0 and 60\u00b0) yield the same range. The curve is symmetric around 45\u00b0.","title":"Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-influence-of-parameters","text":"And with appying modifications on $ v_0 $ \\(g\\) this is how can affect the plot Python Code import numpy as np import matplotlib.pyplot as plt # Common parameters angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) # ========== Effect of Initial Velocity ========== v0_values = [20, 30, 40] # initial velocities in m/s g = 9.81 # gravitational acceleration (Earth) plt.figure(figsize=(10, 6)) for v0 in v0_values: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, ranges, label=f'v\u2080 = {v0} m/s') plt.title(\"Effect of Initial Velocity on Range\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # ========== Effect of Gravity ========== g_values = [9.81, 1.62] # Earth and Moon gravity v0_fixed = 30 # fixed initial velocity plt.figure(figsize=(10, 6)) for g in g_values: ranges = (v0_fixed**2 * np.sin(2 * angles_rad)) / g label = f'g = {g} m/s\u00b2 ({\"Earth\" if g==9.81 else \"Moon\"})' plt.plot(angles_deg, ranges, label=label) plt.title(\"Effect of Gravity on Range\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Key Takeaways: Higher velocity = longer range. Lower gravity (e.g., Moon) = much longer range.","title":"3. Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-practical-applications","text":"Real-World Adjustments Uneven terrain affects landing point \u2192 adjust final height. Air resistance shortens range \u2192 not covered in ideal model. Wind adds horizontal forces \u2192 requires differential equations.","title":"4. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-adding-a-launch-height","text":"Python Code --- ```python def range_with_height(v0, theta_deg, h, g=9.81): theta = np.radians(theta_deg) vx = v0 * np.cos(theta) vy = v0 * np.sin(theta) t_flight = (vy + np.sqrt(vy**2 + 2 * g * h)) / g return vx * t_flight h = 10 # 10 meters launch height ranges = [range_with_height(30, angle, h) for angle in angles_deg] plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges) plt.title(\"Range vs Angle (with Launch Height h = 10 m)\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.show() Insights: Maximum range shifts to lower than 45\u00b0 if starting from a height. Launch height increases overall range.","title":"Example: Adding a Launch Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-of-the-idealized-model","text":"Assumption Real-World Factor Impact No air resistance Drag force Reduces range Constant gravity Varies with altitude Small effect in most cases Flat terrain Hills or valleys Changes point of impact No wind Wind can push/pull projectile Alters horizontal motion Suggestions for Improvement Use scipy.integrate.solve_ivp to include air drag. Use parametric terrain modeling for variable height. Apply wind forces using vector additions in numerical simulation.","title":"5. Limitations of the Idealized Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile range depends heavily on angle , initial speed , and gravitational field . The theoretical model, while idealized, provides great insight and a foundation for more complex simulations. With simple Python tools, we can visualize and analyze this behavior effectively\u2014bridging the gap between theory and practice.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating system where damping, restoring forces, and external periodic forcing interact to create diverse motion patterns. The system transitions from simple harmonic motion to resonance, chaos, and quasiperiodic behavior. These dynamics are essential in various real-world applications, including energy harvesting, structural engineering, and nonlinear oscillatory systems. By systematically varying damping, driving amplitude, and driving frequency, we can observe different behaviors such as synchronized oscillations, resonance, and chaotic motion. Understanding these phenomena helps in designing better mechanical systems, reducing unwanted vibrations, and optimizing energy transfer in oscillatory systems. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = A \\cos(\\omega t)\\] where: \\(\\theta\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(g\\) is gravitational acceleration, \\(l\\) is the length of the pendulum, \\(A\\) is the amplitude of the external forcing, \\(\\omega\\) is the driving frequency. Small-Angle Approximation For small angles ( \\(\\theta\\approx\\) \\(\\sin\\) \\(\\theta\\) ), the equation simplifies to: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\theta = A \\cos(\\omega t)\\] This is a damped, driven harmonic oscillator with an analytical solution in the form: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t + \\phi)\\] where \\(\\theta_0\\) is the initial amplitude, and \\(\\phi\\) is a phase shift. Resonance Conditions Resonance occurs when the driving frequency matches the system's natural frequency: \\[\\omega = \\sqrt{\\frac{g}{l} - \\frac{b^2}{4}}\\] At resonance, the system absorbs maximum energy, leading to large oscillations. 2. Analysis of Dynamics Effect of Parameters on Motion Damping Coefficient ( \\(b\\) ): Higher damping reduces oscillations and suppresses chaotic motion. Driving Amplitude ( \\(A\\) ): Increased forcing can lead to resonance or chaotic behavior. Driving Frequency ( \\(\\omega\\) ): Tuning the frequency can shift the system from periodic to chaotic regimes. Chaos and Transition to Irregular Motion When forcing is strong and damping is moderate, the system can enter chaotic motion, characterized by sensitive dependence on initial conditions. This is analyzed using Poincar\u00e9 sections and bifurcation diagrams . 3. Practical Applications Energy Harvesting: Used in devices that convert oscillatory motion into electricity. Suspension Bridges: Understanding resonance helps prevent structural failures (e.g., Tacoma Narrows Bridge collapse). Biomechanics: Models human gait and oscillatory movements. Electrical Circuits: Analogous to driven RLC circuits. 4. Computational Model & Simulations We use Python to simulate the forced damped pendulum with the Runge-Kutta method for numerical integration. Python Script (forced_damped_pendulum.py) Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s^2) l = 1.0 # Length of pendulum (m) b = 0.2 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Equations of motion def pendulum_eq(t, y): theta, omega_p = y dtheta_dt = omega_p domega_dt = -b * omega_p - (g/l) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = [0, 50] y0 = [0.5, 0] # Initial angle and velocity t_eval = np.linspace(0, 50, 1000) # Solve the system sol = solve_ivp(pendulum_eq, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 5. Graphical Representations 1. Time Evolution of Motion (Plot showing pendulum angle over time.) 2. Phase Portraits \\(\\text{Plot }\\) ( \\(\\theta, \\dot{\\theta}\\) ) \\(\\text{ to visualize motion in phase space.}\\) 3. Poincar\u00e9 Sections \\[\\text{Stroboscopic map of the system, revealing periodic or chaotic behavior.}\\] 4. Bifurcation Diagrams \\[\\text{Graph showing transition to chaos as the driving force increases.}\\] 6. Discussion on Model Limitations & Extensions Limitations *The small-angle approximation fails for large oscillations * *The model assumes a simple sinusoidal driving force. * Possible Extensions Nonlinear Damping: More realistic energy dissipation models Non-Periodic Forcing: Studying real-world irregular driving forces. Coupled Pendulums: Exploring synchronization and complex dynamics. Conclusion The forced damped pendulum provides insights into nonlinear dynamics, resonance, and chaos. By tuning parameters, we observe a transition from regular motion to chaos, revealing fundamental principles that apply to various fields of science and engineering.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating system where damping, restoring forces, and external periodic forcing interact to create diverse motion patterns. The system transitions from simple harmonic motion to resonance, chaos, and quasiperiodic behavior. These dynamics are essential in various real-world applications, including energy harvesting, structural engineering, and nonlinear oscillatory systems. By systematically varying damping, driving amplitude, and driving frequency, we can observe different behaviors such as synchronized oscillations, resonance, and chaotic motion. Understanding these phenomena helps in designing better mechanical systems, reducing unwanted vibrations, and optimizing energy transfer in oscillatory systems.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = A \\cos(\\omega t)\\] where: \\(\\theta\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(g\\) is gravitational acceleration, \\(l\\) is the length of the pendulum, \\(A\\) is the amplitude of the external forcing, \\(\\omega\\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta\\approx\\) \\(\\sin\\) \\(\\theta\\) ), the equation simplifies to: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l} \\theta = A \\cos(\\omega t)\\] This is a damped, driven harmonic oscillator with an analytical solution in the form: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t + \\phi)\\] where \\(\\theta_0\\) is the initial amplitude, and \\(\\phi\\) is a phase shift.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency matches the system's natural frequency: \\[\\omega = \\sqrt{\\frac{g}{l} - \\frac{b^2}{4}}\\] At resonance, the system absorbs maximum energy, leading to large oscillations.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-parameters-on-motion","text":"Damping Coefficient ( \\(b\\) ): Higher damping reduces oscillations and suppresses chaotic motion. Driving Amplitude ( \\(A\\) ): Increased forcing can lead to resonance or chaotic behavior. Driving Frequency ( \\(\\omega\\) ): Tuning the frequency can shift the system from periodic to chaotic regimes.","title":"Effect of Parameters on Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-and-transition-to-irregular-motion","text":"When forcing is strong and damping is moderate, the system can enter chaotic motion, characterized by sensitive dependence on initial conditions. This is analyzed using Poincar\u00e9 sections and bifurcation diagrams .","title":"Chaos and Transition to Irregular Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting: Used in devices that convert oscillatory motion into electricity. Suspension Bridges: Understanding resonance helps prevent structural failures (e.g., Tacoma Narrows Bridge collapse). Biomechanics: Models human gait and oscillatory movements. Electrical Circuits: Analogous to driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-model-simulations","text":"We use Python to simulate the forced damped pendulum with the Runge-Kutta method for numerical integration.","title":"4. Computational Model &amp; Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-script-forced_damped_pendulumpy","text":"Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s^2) l = 1.0 # Length of pendulum (m) b = 0.2 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Equations of motion def pendulum_eq(t, y): theta, omega_p = y dtheta_dt = omega_p domega_dt = -b * omega_p - (g/l) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = [0, 50] y0 = [0.5, 0] # Initial angle and velocity t_eval = np.linspace(0, 50, 1000) # Solve the system sol = solve_ivp(pendulum_eq, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Python Script (forced_damped_pendulum.py)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-graphical-representations","text":"","title":"5. Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-time-evolution-of-motion","text":"(Plot showing pendulum angle over time.)","title":"1. Time Evolution of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-phase-portraits","text":"\\(\\text{Plot }\\) ( \\(\\theta, \\dot{\\theta}\\) ) \\(\\text{ to visualize motion in phase space.}\\)","title":"2. Phase Portraits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-poincare-sections","text":"\\[\\text{Stroboscopic map of the system, revealing periodic or chaotic behavior.}\\]","title":"3. Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-bifurcation-diagrams","text":"\\[\\text{Graph showing transition to chaos as the driving force increases.}\\]","title":"4. Bifurcation Diagrams"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-discussion-on-model-limitations-extensions","text":"","title":"6. Discussion on Model Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"*The small-angle approximation fails for large oscillations * *The model assumes a simple sinusoidal driving force. *","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Nonlinear Damping: More realistic energy dissipation models Non-Periodic Forcing: Studying real-world irregular driving forces. Coupled Pendulums: Exploring synchronization and complex dynamics.","title":"Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum provides insights into nonlinear dynamics, resonance, and chaos. By tuning parameters, we observe a transition from regular motion to chaos, revealing fundamental principles that apply to various fields of science and engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"\ud83c\udf0d Kepler\u2019s Third Law: Orbital Period and Radius Motivation Kepler's Third Law describes a beautiful relationship in orbital mechanics: The square of the orbital period (T) is proportional to the cube of the orbital radius (r): $$ T^2 \\propto r^3 $$ This law allows us to: - Predict satellite periods , - Calculate planetary distances , - Estimate masses of celestial bodies . Derivation For a body of mass $ m $ orbiting a central mass $ M $ (like Earth) in a circular path: Gravitational Force provides the centripetal force : $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} $$ Orbital Period : $$ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\Rightarrow T^2 \\propto r^3 $$ Python Simulation Paste this code into a Python file (e.g. kepler_third_law.py ) and run it to visualize the law. Python Code import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) radii_km = np.linspace(7000, 50000, 100) radii_m = radii_km * 1e3 T_sec = 2 * np.pi * np.sqrt(radii_m**3 / (G * M)) T_hr = T_sec / 3600 # T\u00b2 vs r\u00b3 plt.figure(figsize=(8, 6)) plt.plot(radii_m**3, T_sec**2) plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.grid(True) plt.tight_layout() plt.show() # log-log plot plt.figure(figsize=(8, 6)) plt.loglog(radii_m, T_sec, 'r') plt.title(\"Log-Log Plot: T vs r\") plt.xlabel(\"r (m)\") plt.ylabel(\"T (s)\") plt.grid(True, which='both') plt.tight_layout() plt.show() Real-World Examples A. Moon Orbiting Earth \\(\ud835\udc5f=384,400\u2009km\\) \\(r=384,400km\\) \\(\ud835\udc47\u224827.3days\\) Verifying with the formula: Real-world check: Moon Python Code r_moon = 384400e3 # meters T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) T_moon_days = T_moon / (3600 * 24) print(f\"Computed Moon Period: {T_moon_days:.2f} days\") Matches observed value closely. LEO satellite Python Code r_leo = (6371 + 400) * 1e3 # Earth's radius + altitude T_leo = 2 * np.pi * np.sqrt(r_leo**3 / (G * M)) / 60 # minutes print(f\"LEO Orbital Period: {T_leo:.2f} minutes\") Approx. 90 minutes, as expected for ISS-type orbit. 5. \ud83e\ude90 Elliptical Orbits and Other Bodies Kepler's Third Law holds for elliptical orbits as well, with the orbital radius $ r $ replaced by the semi-major axis $ a $: \\[ T^2 = \\frac{4\\pi^2 a^3}{G(M + m)} \\] Generalization: Works for planets, moons, exoplanets, and binary stars Used in: \ud83c\udf1f Exoplanet detection \ud83c\udf0c Binary star system analysis \ud83d\ude80 Deep space mission planning 6. Conclusion Kepler\u2019s Third Law elegantly connects time and space in celestial mechanics. Through simulation and analysis, we: Verified the relation $ T^2 \\propto r^3 $ Explored real-world examples like the Moon and satellites Built a solid foundation for more advanced studies in orbital dynamics References Kepler, J. Harmonices Mundi (1619) Newton, I. Principia Mathematica NASA & ESA Mission Data NASA Orbit Calculator","title":"\ud83c\udf0d Kepler\u2019s Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-radius","text":"","title":"\ud83c\udf0d Kepler\u2019s Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law describes a beautiful relationship in orbital mechanics: The square of the orbital period (T) is proportional to the cube of the orbital radius (r): $$ T^2 \\propto r^3 $$ This law allows us to: - Predict satellite periods , - Calculate planetary distances , - Estimate masses of celestial bodies .","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"For a body of mass $ m $ orbiting a central mass $ M $ (like Earth) in a circular path: Gravitational Force provides the centripetal force : $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} $$ Orbital Period : $$ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\Rightarrow T^2 \\propto r^3 $$","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"Paste this code into a Python file (e.g. kepler_third_law.py ) and run it to visualize the law. Python Code import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) radii_km = np.linspace(7000, 50000, 100) radii_m = radii_km * 1e3 T_sec = 2 * np.pi * np.sqrt(radii_m**3 / (G * M)) T_hr = T_sec / 3600 # T\u00b2 vs r\u00b3 plt.figure(figsize=(8, 6)) plt.plot(radii_m**3, T_sec**2) plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.grid(True) plt.tight_layout() plt.show() # log-log plot plt.figure(figsize=(8, 6)) plt.loglog(radii_m, T_sec, 'r') plt.title(\"Log-Log Plot: T vs r\") plt.xlabel(\"r (m)\") plt.ylabel(\"T (s)\") plt.grid(True, which='both') plt.tight_layout() plt.show() Real-World Examples A. Moon Orbiting Earth \\(\ud835\udc5f=384,400\u2009km\\) \\(r=384,400km\\) \\(\ud835\udc47\u224827.3days\\) Verifying with the formula:","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-check-moon","text":"Python Code r_moon = 384400e3 # meters T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) T_moon_days = T_moon / (3600 * 24) print(f\"Computed Moon Period: {T_moon_days:.2f} days\") Matches observed value closely.","title":"Real-world check: Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#leo-satellite","text":"Python Code r_leo = (6371 + 400) * 1e3 # Earth's radius + altitude T_leo = 2 * np.pi * np.sqrt(r_leo**3 / (G * M)) / 60 # minutes print(f\"LEO Orbital Period: {T_leo:.2f} minutes\") Approx. 90 minutes, as expected for ISS-type orbit.","title":"LEO satellite"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-elliptical-orbits-and-other-bodies","text":"Kepler's Third Law holds for elliptical orbits as well, with the orbital radius $ r $ replaced by the semi-major axis $ a $: \\[ T^2 = \\frac{4\\pi^2 a^3}{G(M + m)} \\]","title":"5. \ud83e\ude90 Elliptical Orbits and Other Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#generalization","text":"Works for planets, moons, exoplanets, and binary stars Used in: \ud83c\udf1f Exoplanet detection \ud83c\udf0c Binary star system analysis \ud83d\ude80 Deep space mission planning","title":"Generalization:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion","text":"Kepler\u2019s Third Law elegantly connects time and space in celestial mechanics. Through simulation and analysis, we: Verified the relation $ T^2 \\propto r^3 $ Explored real-world examples like the Moon and satellites Built a solid foundation for more advanced studies in orbital dynamics","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Kepler, J. Harmonices Mundi (1619) Newton, I. Principia Mathematica NASA & ESA Mission Data NASA Orbit Calculator","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Introduction The forced damped pendulum is an example of a system exhibiting complex behavior due to the interplay of damping, restoring forces, and external periodic driving forces. This simulation explores resonance, chaos, and quasiperiodic motion through numerical integration. Mathematical Model The motion of the forced damped pendulum is governed by the equation: \\(\\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\) where: \\(b\\) is the damping coefficient, \\(g\\) is the acceleration due to gravity, \\(L\\) is the length of the pendulum, \\(A\\) is the amplitude of the driving force, - \\(\\omega\\) is the driving frequency. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2/3 # Driving frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dydt = [ omega_t, -b * omega_t - (g/L) * np.sin(theta) + A * np.cos(omega * t) ] return dydt # Time span t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Initial conditions y0 = [0.2, 0] # Initial angle and velocity # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Phase portrait plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.8) plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.grid() plt.show() # Poincare section (stroboscopic map) poincare_times = np.arange(0, 100, 2*np.pi/omega) poincare_points = [] for t_p in poincare_times: idx = (np.abs(sol.t - t_p)).argmin() poincare_points.append([sol.y[0][idx], sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(8, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='red') plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show() # Time series plot plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel(\"Time (s)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Time Evolution of Theta\") plt.legend() plt.grid() plt.show() # Bifurcation diagram A_values = np.linspace(0.5, 2.0, 20) th_values = [] for A in A_values: def system(t, y): return [y[1], -b * y[1] - (g/L) * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(system, t_span, y0, t_eval=t_eval, method='RK45') th_values.append(sol.y[0][-500:]) plt.figure(figsize=(8, 6)) for i, A in enumerate(A_values): plt.scatter([A] * len(th_values[i]), th_values[i], s=1, color='blue') plt.xlabel(\"Driving Force Amplitude (A)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Bifurcation Diagram\") plt.grid() plt.show() --- Results The simulation produces: Phase Portrait : Displays how the system evolves in phase space. Poincar\u00e9 Section : A stroboscopic map showing discrete points at specific time intervals, revealing periodic or chaotic behavior. Time Series Plot : Shows the evolution of the pendulum\u2019s angle over time. Bifurcation Diagram : Demonstrates the transition to chaos as the driving force amplitude increases. Conclusion The forced damped pendulum demonstrates a range of behaviors from simple oscillations to chaos, depending on parameter values. This study helps in understanding nonlinear dynamics in real-world systems like mechanical oscillators and electrical circuits.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The forced damped pendulum is an example of a system exhibiting complex behavior due to the interplay of damping, restoring forces, and external periodic driving forces. This simulation explores resonance, chaos, and quasiperiodic motion through numerical integration.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-model","text":"The motion of the forced damped pendulum is governed by the equation: \\(\\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\) where: \\(b\\) is the damping coefficient, \\(g\\) is the acceleration due to gravity, \\(L\\) is the length of the pendulum, \\(A\\) is the amplitude of the driving force,","title":"Mathematical Model"},{"location":"1%20Physics/2%20Gravity/Problem_2/#-omega-is-the-driving-frequency","text":"Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2/3 # Driving frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dydt = [ omega_t, -b * omega_t - (g/L) * np.sin(theta) + A * np.cos(omega * t) ] return dydt # Time span t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Initial conditions y0 = [0.2, 0] # Initial angle and velocity # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Phase portrait plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.8) plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.grid() plt.show() # Poincare section (stroboscopic map) poincare_times = np.arange(0, 100, 2*np.pi/omega) poincare_points = [] for t_p in poincare_times: idx = (np.abs(sol.t - t_p)).argmin() poincare_points.append([sol.y[0][idx], sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(8, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='red') plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular velocity (rad/s)\") plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show() # Time series plot plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel(\"Time (s)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Time Evolution of Theta\") plt.legend() plt.grid() plt.show() # Bifurcation diagram A_values = np.linspace(0.5, 2.0, 20) th_values = [] for A in A_values: def system(t, y): return [y[1], -b * y[1] - (g/L) * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(system, t_span, y0, t_eval=t_eval, method='RK45') th_values.append(sol.y[0][-500:]) plt.figure(figsize=(8, 6)) for i, A in enumerate(A_values): plt.scatter([A] * len(th_values[i]), th_values[i], s=1, color='blue') plt.xlabel(\"Driving Force Amplitude (A)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Bifurcation Diagram\") plt.grid() plt.show() ---","title":"- \\(\\omega\\) is the driving frequency."},{"location":"1%20Physics/2%20Gravity/Problem_2/#results","text":"The simulation produces: Phase Portrait : Displays how the system evolves in phase space. Poincar\u00e9 Section : A stroboscopic map showing discrete points at specific time intervals, revealing periodic or chaotic behavior. Time Series Plot : Shows the evolution of the pendulum\u2019s angle over time. Bifurcation Diagram : Demonstrates the transition to chaos as the driving force amplitude increases.","title":"Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"The forced damped pendulum demonstrates a range of behaviors from simple oscillations to chaos, depending on parameter values. This study helps in understanding nonlinear dynamics in real-world systems like mechanical oscillators and electrical circuits.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Theoretical Foundation The motion of the payload is governed by Newton's Law of Universal Gravitation: \\[F = G \\frac{M_E m}{r^2}\\] Where: \\(F\\) is the gravitational force \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N m}^2/\\text{kg}^2\\) ) \\(M_E\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ) \\(m\\) is the mass of the payload \\(r\\) is the distance between the payload and Earth's center The acceleration of the payload is: \\[a = \\frac{F}{m} = \\frac{G M_E}{r^2}\\] We can use numerical integration (e.g., Euler's method, Runge-Kutta) to solve the equations of motion and determine the trajectory. Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 ME = 5.972e24 RE = 6.371e6 # Earth's radius def gravity(r): return -G * ME / np.linalg.norm(r)**3 * r def simulate_trajectory(r0, v0, dt, duration): num_steps = int(duration / dt) r = np.zeros((num_steps, 2)) v = np.zeros((num_steps, 2)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): a = gravity(r[i-1]) v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r # Example 1: Elliptical Orbit r0_ellipse = np.array([RE + 400e3, 0.0]) v0_ellipse = np.array([0.0, 7.5e3]) dt = 10 duration = 8000 r_ellipse = simulate_trajectory(r0_ellipse, v0_ellipse, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_ellipse[:, 0], r_ellipse[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Elliptical Orbit\") plt.axis('equal') plt.grid(True) plt.savefig('elliptical_orbit.png') plt.show() # Example 2: Escape Trajectory r0_escape = np.array([RE + 200e3, 0.0]) v0_escape = np.array([0.0, 11.5e3]) r_escape = simulate_trajectory(r0_escape, v0_escape, dt, duration*3) plt.figure(figsize=(8, 8)) plt.plot(r_escape[:, 0], r_escape[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Escape Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('escape_trajectory.png') plt.show() # Example 3: Re-entry Trajectory r0_reentry = np.array([RE + 500e3, 0.0]) v0_reentry = np.array([0.0, -7.0e3]) r_reentry = simulate_trajectory(r0_reentry, v0_reentry, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_reentry[:, 0], r_reentry[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Re-entry Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('reentry_trajectory.png') plt.show() # Example 4: Parabolic Trajectory (Escape Velocity) r0_parabolic = np.array([RE + 300e3, 0.0]) v0_parabolic = np.array([0.0, np.sqrt(2 * G * ME / (RE + 300e3))]) # escape velocity r_parabolic = simulate_trajectory(r0_parabolic, v0_parabolic, dt, duration*2) plt.figure(figsize=(8, 8)) plt.plot(r_parabolic[:, 0], r_parabolic[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Parabolic Trajectory (Escape)\") plt.axis('equal') plt.grid(True) plt.savefig('parabolic_trajectory.png') plt.show() Graphical Representations Discussion Elliptical Orbits: When the initial velocity is less than the escape velocity, and the trajectory does not intersect the Earth's surface, the payload will follow an elliptical orbit. Escape Trajectories: If the initial velocity is greater than the escape velocity, the payload will follow a hyperbolic trajectory and escape Earth's gravitational pull. Re-entry Trajectories: If the initial velocity is directed towards Earth, the payload will follow a trajectory that intersects Earth's surface, resulting in re-entry. Parabolic Trajectory: When the velocity equals the escape velocity, the trajectory will be parabolic. These examples illustrate how initial conditions significantly impact the payload's trajectory, which is crucial for space mission planning, satellite deployment, and understanding celestial mechanics. Conclusion This analysis and simulation demonstrate the complex interplay between initial conditions and gravitational forces that determine a payload's trajectory near Earth. Numerical methods allow us to visualize and analyze these trajectories, providing valuable insights for various space-related applications. ```","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"The motion of the payload is governed by Newton's Law of Universal Gravitation: \\[F = G \\frac{M_E m}{r^2}\\] Where: \\(F\\) is the gravitational force \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N m}^2/\\text{kg}^2\\) ) \\(M_E\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ) \\(m\\) is the mass of the payload \\(r\\) is the distance between the payload and Earth's center The acceleration of the payload is: \\[a = \\frac{F}{m} = \\frac{G M_E}{r^2}\\] We can use numerical integration (e.g., Euler's method, Runge-Kutta) to solve the equations of motion and determine the trajectory. Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 ME = 5.972e24 RE = 6.371e6 # Earth's radius def gravity(r): return -G * ME / np.linalg.norm(r)**3 * r def simulate_trajectory(r0, v0, dt, duration): num_steps = int(duration / dt) r = np.zeros((num_steps, 2)) v = np.zeros((num_steps, 2)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): a = gravity(r[i-1]) v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r # Example 1: Elliptical Orbit r0_ellipse = np.array([RE + 400e3, 0.0]) v0_ellipse = np.array([0.0, 7.5e3]) dt = 10 duration = 8000 r_ellipse = simulate_trajectory(r0_ellipse, v0_ellipse, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_ellipse[:, 0], r_ellipse[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Elliptical Orbit\") plt.axis('equal') plt.grid(True) plt.savefig('elliptical_orbit.png') plt.show() # Example 2: Escape Trajectory r0_escape = np.array([RE + 200e3, 0.0]) v0_escape = np.array([0.0, 11.5e3]) r_escape = simulate_trajectory(r0_escape, v0_escape, dt, duration*3) plt.figure(figsize=(8, 8)) plt.plot(r_escape[:, 0], r_escape[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Escape Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('escape_trajectory.png') plt.show() # Example 3: Re-entry Trajectory r0_reentry = np.array([RE + 500e3, 0.0]) v0_reentry = np.array([0.0, -7.0e3]) r_reentry = simulate_trajectory(r0_reentry, v0_reentry, dt, duration) plt.figure(figsize=(8, 8)) plt.plot(r_reentry[:, 0], r_reentry[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Re-entry Trajectory\") plt.axis('equal') plt.grid(True) plt.savefig('reentry_trajectory.png') plt.show() # Example 4: Parabolic Trajectory (Escape Velocity) r0_parabolic = np.array([RE + 300e3, 0.0]) v0_parabolic = np.array([0.0, np.sqrt(2 * G * ME / (RE + 300e3))]) # escape velocity r_parabolic = simulate_trajectory(r0_parabolic, v0_parabolic, dt, duration*2) plt.figure(figsize=(8, 8)) plt.plot(r_parabolic[:, 0], r_parabolic[:, 1]) circle = plt.Circle((0, 0), RE, color='blue', fill=True) plt.gca().add_artist(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Parabolic Trajectory (Escape)\") plt.axis('equal') plt.grid(True) plt.savefig('parabolic_trajectory.png') plt.show()","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representations","text":"","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"Elliptical Orbits: When the initial velocity is less than the escape velocity, and the trajectory does not intersect the Earth's surface, the payload will follow an elliptical orbit. Escape Trajectories: If the initial velocity is greater than the escape velocity, the payload will follow a hyperbolic trajectory and escape Earth's gravitational pull. Re-entry Trajectories: If the initial velocity is directed towards Earth, the payload will follow a trajectory that intersects Earth's surface, resulting in re-entry. Parabolic Trajectory: When the velocity equals the escape velocity, the trajectory will be parabolic. These examples illustrate how initial conditions significantly impact the payload's trajectory, which is crucial for space mission planning, satellite deployment, and understanding celestial mechanics.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"This analysis and simulation demonstrate the complex interplay between initial conditions and gravitational forces that determine a payload's trajectory near Earth. Numerical methods allow us to visualize and analyze these trajectories, providing valuable insights for various space-related applications. ```","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface from Multiple Point Sources Motivation Interference patterns on a water surface provide an intuitive visualization of wave superposition. By analyzing the interaction of waves emanating from multiple point sources arranged in regular polygon configurations, we can explore the intricate dynamics of wave phenomena, including constructive and destructive interference. This study aims to deepen our understanding of wave behavior through simulation and visualization. Task Analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of various regular polygons. Theoretical Foundation The displacement of a circular wave on a water surface from a point source at \\((x_0, y_0)\\) is given by: \\[\\eta(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi)\\] Where: \\(\\eta(x, y, t)\\) is the displacement at \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number. \\(\\omega = 2\\pi f\\) is the angular frequency. \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source. \\(\\phi\\) is the initial phase. The superposition of waves from \\(N\\) sources is: \\[\\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t)\\] Python Simulation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation def wave_displacement(x, y, x0, y0, A, k, omega, t, phi): r = np.sqrt((x - x0)**2 + (y - y0)**2) return A * np.cos(k * r - omega * t + phi) def superposition(x, y, sources, A, k, omega, t, phi): total_displacement = np.zeros_like(x) for x0, y0 in sources: total_displacement += wave_displacement(x, y, x0, y0, A, k, omega, t, phi) return total_displacement def generate_sources(n, radius): theta = np.linspace(0, 2 * np.pi, n, endpoint=False) return [(radius * np.cos(t), radius * np.sin(t)) for t in theta] def visualize_interference(sources, A, wavelength, frequency, duration, frames, filename): k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t_values = np.linspace(0, duration, frames) x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(8, 8)) img = ax.imshow(superposition(X, Y, sources, A, k, omega, 0, phi), cmap='viridis', extent=[-3, 3, -3, 3], animated=True) def update(frame): img.set_array(superposition(X, Y, sources, A, k, omega, t_values[frame], phi)) return img, ani = animation.FuncAnimation(fig, update, frames=frames, blit=True) ani.save(filename, writer='pillow', fps=10) plt.close() # Parameters A = 1 wavelength = 1 frequency = 1 duration = 10 frames = 100 # Examples # Triangle triangle_sources = generate_sources(3, 1) visualize_interference(triangle_sources, A, wavelength, frequency, duration, frames, 'triangle_interference.gif') print(\"Triangle interference animation generated.\") # Square square_sources = generate_sources(4, 1) visualize_interference(square_sources, A, wavelength, frequency, duration, frames, 'square_interference.gif') print(\"Square interference animation generated.\") # Pentagon pentagon_sources = generate_sources(5, 1) visualize_interference(pentagon_sources, A, wavelength, frequency, duration, frames, 'pentagon_interference.gif') print(\"Pentagon interference animation generated.\") # Hexagon hexagon_sources = generate_sources(6, 1) visualize_interference(hexagon_sources, A, wavelength, frequency, duration, frames, 'hexagon_interference.gif') print(\"Hexagon interference animation generated.\") # Octagon octagon_sources = generate_sources(8, 1) visualize_interference(octagon_sources, A, wavelength, frequency, duration, frames, 'octagon_interference.gif') print(\"Octagon interference animation generated.\") # Circle (Approximation) circle_sources = generate_sources(30, 1) visualize_interference(circle_sources, A, wavelength, frequency, duration, frames, 'circle_interference.gif') print(\"Circle interference animation generated.\") Graphical Representations Triangle Interference Pattern \u2013 Wave interference from 3 point sources. Square Interference Pattern \u2013 Wave interference from 4 point sources. Pentagon Interference Pattern \u2013 Wave interference from 5 point sources. Octagon Interference Pattern \u2013 Wave interference from 8 point sources. Circular Interference Approximation \u2013 Wave interference from 30 point sources. Analysis Constructive Interference: Occurs where waves align in phase, resulting in increased amplitude. In our visualizations, these regions are bright. Destructive Interference: Occurs where waves align out of phase, resulting in decreased or zero amplitude. These regions are dark. Regular Polygons: The number of sources and their arrangement directly influence the complexity of the interference patterns. Higher numbers of sources result in more intricate patterns. Circular Approximation: As the number of sources increases, the polygon approaches a circle, resulting in a more uniform and detailed interference pattern. Animation: The animations illustrate the dynamic nature of interference patterns, showing how they evolve over time. Conclusion This study demonstrates the complex interference patterns that emerge from multiple point sources arranged in regular polygons. By visualizing these patterns, we gain a deeper understanding of wave superposition and its dependence on source geometry. This analysis offers a practical approach to exploring wave phenomena and their applications in various fields.","title":"Interference Patterns on a Water Surface from Multiple Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface-from-multiple-point-sources","text":"","title":"Interference Patterns on a Water Surface from Multiple Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns on a water surface provide an intuitive visualization of wave superposition. By analyzing the interaction of waves emanating from multiple point sources arranged in regular polygon configurations, we can explore the intricate dynamics of wave phenomena, including constructive and destructive interference. This study aims to deepen our understanding of wave behavior through simulation and visualization.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of various regular polygons.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"The displacement of a circular wave on a water surface from a point source at \\((x_0, y_0)\\) is given by: \\[\\eta(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi)\\] Where: \\(\\eta(x, y, t)\\) is the displacement at \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number. \\(\\omega = 2\\pi f\\) is the angular frequency. \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source. \\(\\phi\\) is the initial phase. The superposition of waves from \\(N\\) sources is: \\[\\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t)\\] Python Simulation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation def wave_displacement(x, y, x0, y0, A, k, omega, t, phi): r = np.sqrt((x - x0)**2 + (y - y0)**2) return A * np.cos(k * r - omega * t + phi) def superposition(x, y, sources, A, k, omega, t, phi): total_displacement = np.zeros_like(x) for x0, y0 in sources: total_displacement += wave_displacement(x, y, x0, y0, A, k, omega, t, phi) return total_displacement def generate_sources(n, radius): theta = np.linspace(0, 2 * np.pi, n, endpoint=False) return [(radius * np.cos(t), radius * np.sin(t)) for t in theta] def visualize_interference(sources, A, wavelength, frequency, duration, frames, filename): k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t_values = np.linspace(0, duration, frames) x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(8, 8)) img = ax.imshow(superposition(X, Y, sources, A, k, omega, 0, phi), cmap='viridis', extent=[-3, 3, -3, 3], animated=True) def update(frame): img.set_array(superposition(X, Y, sources, A, k, omega, t_values[frame], phi)) return img, ani = animation.FuncAnimation(fig, update, frames=frames, blit=True) ani.save(filename, writer='pillow', fps=10) plt.close() # Parameters A = 1 wavelength = 1 frequency = 1 duration = 10 frames = 100 # Examples # Triangle triangle_sources = generate_sources(3, 1) visualize_interference(triangle_sources, A, wavelength, frequency, duration, frames, 'triangle_interference.gif') print(\"Triangle interference animation generated.\") # Square square_sources = generate_sources(4, 1) visualize_interference(square_sources, A, wavelength, frequency, duration, frames, 'square_interference.gif') print(\"Square interference animation generated.\") # Pentagon pentagon_sources = generate_sources(5, 1) visualize_interference(pentagon_sources, A, wavelength, frequency, duration, frames, 'pentagon_interference.gif') print(\"Pentagon interference animation generated.\") # Hexagon hexagon_sources = generate_sources(6, 1) visualize_interference(hexagon_sources, A, wavelength, frequency, duration, frames, 'hexagon_interference.gif') print(\"Hexagon interference animation generated.\") # Octagon octagon_sources = generate_sources(8, 1) visualize_interference(octagon_sources, A, wavelength, frequency, duration, frames, 'octagon_interference.gif') print(\"Octagon interference animation generated.\") # Circle (Approximation) circle_sources = generate_sources(30, 1) visualize_interference(circle_sources, A, wavelength, frequency, duration, frames, 'circle_interference.gif') print(\"Circle interference animation generated.\")","title":"Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#graphical-representations","text":"Triangle Interference Pattern \u2013 Wave interference from 3 point sources. Square Interference Pattern \u2013 Wave interference from 4 point sources. Pentagon Interference Pattern \u2013 Wave interference from 5 point sources. Octagon Interference Pattern \u2013 Wave interference from 8 point sources. Circular Interference Approximation \u2013 Wave interference from 30 point sources.","title":"Graphical Representations"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis","text":"Constructive Interference: Occurs where waves align in phase, resulting in increased amplitude. In our visualizations, these regions are bright. Destructive Interference: Occurs where waves align out of phase, resulting in decreased or zero amplitude. These regions are dark. Regular Polygons: The number of sources and their arrangement directly influence the complexity of the interference patterns. Higher numbers of sources result in more intricate patterns. Circular Approximation: As the number of sources increases, the polygon approaches a circle, resulting in a more uniform and detailed interference pattern. Animation: The animations illustrate the dynamic nature of interference patterns, showing how they evolve over time.","title":"Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This study demonstrates the complex interference patterns that emerge from multiple point sources arranged in regular polygons. By visualizing these patterns, we gain a deeper understanding of wave superposition and its dependence on source geometry. This analysis offers a practical approach to exploring wave phenomena and their applications in various fields.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Equivalent Resistance Using Graph Theory Problem Overview Calculating the equivalent resistance in electrical circuits is essential for designing and analyzing efficient systems. While traditional methods work well for simple circuits, graph theory offers a powerful tool to handle complex resistor networks , especially with nested or looped configurations. Motivation Traditional circuit analysis relies on identifying series and parallel components. This becomes difficult in large or irregular circuits. Graph theory provides a systematic, programmable approach using nodes ( junctions ) and edges ( resistors ). Enables automation , visualization , and scalability . Circuit as a Graph Nodes = electrical junctions Edges = resistors (with weight = resistance) Goal: Reduce graph to one equivalent edge between input and output nodes Algorithm Description Graph Simplification Strategy Detect series connections : Nodes with degree 2 (except terminals) Detect parallel connections : Multiple edges between same nodes or cycles Reduce step by step : Combine series: \\(( R_{eq} = R_1 + R_2 )\\) Combine parallel: \\(( \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} )\\) ## Examples & Visualizations Example 1: Series Circuit Two resistors are connected end-to-end: A \u2192 B : 10\u202f \\(\u03a9\\) B \u2192 C : 5\u202f \\(\u03a9\\) They are in series , so the equivalent resistance is: \\[ R_{\\text{eq}} = R_1 + R_2 = 10\\,\\Omega + 5\\,\\Omega = 15\\,\\Omega \\] Example 2: Parallel Circuit Two resistors are connected between the same nodes A and B : A \u2194 B : 10\u202f \\(\u03a9\\) A \u2194 B : 20\u202f \\(\u03a9\\) They are in parallel , so: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\quad\\Rightarrow\\quad R_{\\text{eq}} = \\frac{20}{3} \\approx 6.67\\,\\Omega \\] Example 3: Nested Configuration We have two paths from A to C : Path 1 : A \u2192 B \u2192 C AB = 5\u202f \\(\u03a9\\) , B C = 5\u202f \\(\u03a9\\) \u2192 total = 10\u202f \\(\u03a9\\) Path 2 : Direct A \u2192 C = 10\u202f \\(\u03a9\\) These two 10\u202f \\(\u03a9\\) paths are in parallel , so : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{10} = \\frac{1}{5} \\quad\\Rightarrow\\quad R_{\\text{eq}} = 5\\,\\Omega \\] Pseudocode ```pseudo function simplify_circuit(graph, input_node, output_node): repeat: for each node in graph: if node is not input/output and has degree 2: merge series resistors for each pair of nodes with parallel edges: combine using parallel rule until no more simplifications return resistance between input_node and output_node","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-overview","text":"Calculating the equivalent resistance in electrical circuits is essential for designing and analyzing efficient systems. While traditional methods work well for simple circuits, graph theory offers a powerful tool to handle complex resistor networks , especially with nested or looped configurations.","title":"Problem Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"Traditional circuit analysis relies on identifying series and parallel components. This becomes difficult in large or irregular circuits. Graph theory provides a systematic, programmable approach using nodes ( junctions ) and edges ( resistors ). Enables automation , visualization , and scalability .","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#circuit-as-a-graph","text":"Nodes = electrical junctions Edges = resistors (with weight = resistance) Goal: Reduce graph to one equivalent edge between input and output nodes","title":"Circuit as a Graph"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#algorithm-description","text":"","title":"Algorithm Description"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#graph-simplification-strategy","text":"Detect series connections : Nodes with degree 2 (except terminals) Detect parallel connections : Multiple edges between same nodes or cycles Reduce step by step : Combine series: \\(( R_{eq} = R_1 + R_2 )\\) Combine parallel: \\(( \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} )\\) ## Examples & Visualizations","title":"Graph Simplification Strategy"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-1-series-circuit","text":"Two resistors are connected end-to-end: A \u2192 B : 10\u202f \\(\u03a9\\) B \u2192 C : 5\u202f \\(\u03a9\\) They are in series , so the equivalent resistance is: \\[ R_{\\text{eq}} = R_1 + R_2 = 10\\,\\Omega + 5\\,\\Omega = 15\\,\\Omega \\]","title":"Example 1: Series Circuit"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-2-parallel-circuit","text":"Two resistors are connected between the same nodes A and B : A \u2194 B : 10\u202f \\(\u03a9\\) A \u2194 B : 20\u202f \\(\u03a9\\) They are in parallel , so: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\quad\\Rightarrow\\quad R_{\\text{eq}} = \\frac{20}{3} \\approx 6.67\\,\\Omega \\]","title":"Example 2: Parallel Circuit"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-3-nested-configuration","text":"We have two paths from A to C : Path 1 : A \u2192 B \u2192 C AB = 5\u202f \\(\u03a9\\) , B C = 5\u202f \\(\u03a9\\) \u2192 total = 10\u202f \\(\u03a9\\) Path 2 : Direct A \u2192 C = 10\u202f \\(\u03a9\\) These two 10\u202f \\(\u03a9\\) paths are in parallel , so : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{10} = \\frac{1}{5} \\quad\\Rightarrow\\quad R_{\\text{eq}} = 5\\,\\Omega \\]","title":"Example 3: Nested Configuration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#pseudocode","text":"```pseudo function simplify_circuit(graph, input_node, output_node): repeat: for each node in graph: if node is not input/output and has degree 2: merge series resistors for each pair of nodes with parallel edges: combine using parallel rule until no more simplifications return resistance between input_node and output_node","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Using Graph Theory Problem Overview Calculating the equivalent resistance in electrical circuits is essential for designing and analyzing efficient systems. While traditional methods work well for simple circuits, graph theory offers a powerful tool to handle complex resistor networks , especially with nested or looped configurations. Motivation Traditional circuit analysis relies on identifying series and parallel components. This becomes difficult in large or irregular circuits. Graph theory provides a systematic, programmable approach using nodes ( junctions ) and edges ( resistors ). Enables automation , visualization , and scalability . Circuit as a Graph Nodes = electrical junctions Edges = resistors (with weight = resistance) Goal: Reduce graph to one equivalent edge between input and output nodes Algorithm Description Graph Simplification Strategy Detect series connections : Nodes with degree 2 (except terminals) Detect parallel connections : Multiple edges between same nodes or cycles Reduce step by step : Combine series: \\(( R_{eq} = R_1 + R_2 )\\) Combine parallel: \\(( \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} )\\) ## Examples & Visualizations Example 1: Series Circuit Two resistors are connected end-to-end: A \u2192 B : 10\u202f \\(\u03a9\\) B \u2192 C : 5\u202f \\(\u03a9\\) They are in series , so the equivalent resistance is: \\[ R_{\\text{eq}} = R_1 + R_2 = 10\\,\\Omega + 5\\,\\Omega = 15\\,\\Omega \\] Example 2: Parallel Circuit Two resistors are connected between the same nodes A and B : A \u2194 B : 10\u202f \\(\u03a9\\) A \u2194 B : 20\u202f \\(\u03a9\\) They are in parallel , so: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\quad\\Rightarrow\\quad R_{\\text{eq}} = \\frac{20}{3} \\approx 6.67\\,\\Omega \\] Example 3: Nested Configuration We have two paths from A to C : Path 1 : A \u2192 B \u2192 C AB = 5\u202f \\(\u03a9\\) , B C = 5\u202f \\(\u03a9\\) \u2192 total = 10\u202f \\(\u03a9\\) Path 2 : Direct A \u2192 C = 10\u202f \\(\u03a9\\) These two 10\u202f \\(\u03a9\\) paths are in parallel , so : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{10} = \\frac{1}{5} \\quad\\Rightarrow\\quad R_{\\text{eq}} = 5\\,\\Omega \\] Pseudocode ```pseudo function simplify_circuit(graph, input_node, output_node): repeat: for each node in graph: if node is not input/output and has degree 2: merge series resistors for each pair of nodes with parallel edges: combine using parallel rule until no more simplifications return resistance between input_node and output_node","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-overview","text":"Calculating the equivalent resistance in electrical circuits is essential for designing and analyzing efficient systems. While traditional methods work well for simple circuits, graph theory offers a powerful tool to handle complex resistor networks , especially with nested or looped configurations.","title":"Problem Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Traditional circuit analysis relies on identifying series and parallel components. This becomes difficult in large or irregular circuits. Graph theory provides a systematic, programmable approach using nodes ( junctions ) and edges ( resistors ). Enables automation , visualization , and scalability .","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-as-a-graph","text":"Nodes = electrical junctions Edges = resistors (with weight = resistance) Goal: Reduce graph to one equivalent edge between input and output nodes","title":"Circuit as a Graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-simplification-strategy","text":"Detect series connections : Nodes with degree 2 (except terminals) Detect parallel connections : Multiple edges between same nodes or cycles Reduce step by step : Combine series: \\(( R_{eq} = R_1 + R_2 )\\) Combine parallel: \\(( \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} )\\) ## Examples & Visualizations","title":"Graph Simplification Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series-circuit","text":"Two resistors are connected end-to-end: A \u2192 B : 10\u202f \\(\u03a9\\) B \u2192 C : 5\u202f \\(\u03a9\\) They are in series , so the equivalent resistance is: \\[ R_{\\text{eq}} = R_1 + R_2 = 10\\,\\Omega + 5\\,\\Omega = 15\\,\\Omega \\]","title":"Example 1: Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel-circuit","text":"Two resistors are connected between the same nodes A and B : A \u2194 B : 10\u202f \\(\u03a9\\) A \u2194 B : 20\u202f \\(\u03a9\\) They are in parallel , so: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\quad\\Rightarrow\\quad R_{\\text{eq}} = \\frac{20}{3} \\approx 6.67\\,\\Omega \\]","title":"Example 2: Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-configuration","text":"We have two paths from A to C : Path 1 : A \u2192 B \u2192 C AB = 5\u202f \\(\u03a9\\) , B C = 5\u202f \\(\u03a9\\) \u2192 total = 10\u202f \\(\u03a9\\) Path 2 : Direct A \u2192 C = 10\u202f \\(\u03a9\\) These two 10\u202f \\(\u03a9\\) paths are in parallel , so : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{10} = \\frac{1}{5} \\quad\\Rightarrow\\quad R_{\\text{eq}} = 5\\,\\Omega \\]","title":"Example 3: Nested Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"```pseudo function simplify_circuit(graph, input_node, output_node): repeat: for each node in graph: if node is not input/output and has degree 2: merge series resistors for each pair of nodes with parallel edges: combine using parallel rule until no more simplifications return resistance between input_node and output_node","title":"Pseudocode"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Exploring the Central Limit Theorem (CLT) Through Simulations Motivation The Central Limit Theorem (CLT) is a key concept in statistics: Regardless of the population's distribution, the distribution of the sample mean becomes approximately normal as the sample size increases. Why is this important? - It justifies using the normal distribution in many real-world situations. - Helps estimate population parameters. - Essential in quality control, finance, and data analysis. Task 1 : Simulating Sampling Distributions Population Distributions: We will use three types of populations: - Uniform : Equal chance across a range. - Exponential : Time between random events. - Binomial : Count of successes over trials. Python code --- import numpy as np def generate_population(dist, size=100000): if dist == \"uniform\": return np.random.uniform(0, 1, size) elif dist == \"exponential\": return np.random.exponential(scale=1.0, size=size) elif dist == \"binomial\": return np.random.binomial(n=10, p=0.5, size=size) --- Task 2 : Sampling and Visualization Sample and Calculate Sample Means: Python code import numpy as np import matplotlib.pyplot as plt # Define the simulation function def simulate_sampling(population, sample_size=30, n_samples=1000): return [ np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(n_samples) ] # Create a population (e.g., a normal distribution) population = np.random.normal(loc=50, scale=10, size=10000) # Simulate the sampling process sample_means = simulate_sampling(population, sample_size=30, n_samples=1000) # Plot the distribution of sample means plt.figure(figsize=(10, 6)) plt.hist(sample_means, bins=30, edgecolor='black', alpha=0.7) plt.title('Distribution of Sample Means') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.grid(True) plt.show() Visualize the Sampling Distributions: Python code import matplotlib.pyplot as plt import seaborn as sns import numpy as np sns.set(style=\"whitegrid\") # Simulate sampling def simulate_sampling(population, sample_size=30, n_samples=1000): return [ np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(n_samples) ] # Generate different types of populations def generate_population(distribution_type, size=10000): if distribution_type == \"uniform\": return np.random.uniform(low=0, high=10, size=size) # Uniform distribution elif distribution_type == \"exponential\": return np.random.exponential(scale=1, size=size) # Exponential distribution elif distribution_type == \"binomial\": return np.random.binomial(n=10, p=0.5, size=size) # Binomial distribution else: raise ValueError(\"Unknown distribution type\") # Plot the sampling distribution def plot_sampling_distribution(dist_name, population): sample_sizes = [5, 10, 30, 50] plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes): sample_means = simulate_sampling(population, sample_size=size) plt.subplot(2, 2, i+1) sns.histplot(sample_means, bins=30, kde=True, color=\"skyblue\") plt.title(f\"{dist_name.capitalize()} Dist. - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.tight_layout() plt.suptitle(f\"CLT Simulation for {dist_name.capitalize()} Population\", fontsize=18, y=1.03) plt.show() # Example usage uniform_pop = generate_population(\"uniform\") plot_sampling_distribution(\"uniform\", uniform_pop) Task 3 : Parameter Exploration Run Simulations: Python code # Uniform uniform_pop = generate_population(\"uniform\") plot_sampling_distribution(\"uniform\", uniform_pop) # Exponential exp_pop = generate_population(\"exponential\") plot_sampling_distribution(\"exponential\", exp_pop) # Binomial binom_pop = generate_population(\"binomial\") plot_sampling_distribution(\"binomial\", binom_pop) Uniform Population Distribution Exponential Population Distribution Biominal Population Distribution Observations: Sample means tend toward normal shape. Variance of sample means decreases with sample size. Heavily skewed populations (e.g. exponential) require larger sample sizes. Task 4 : Practical Applications of CLT Manufacturing : Mean weight/size/quality of products. Polling : Estimating average opinions. Finance : Average return on investments. Science : Mean experimental measurements. Why It Works: Sample means are sums of random variables. Sums tend to normality via CLT. Conclusion The CLT enables the use of normal-based statistical methods. Useful even when the population is not normally distributed. Larger sample sizes lead to more accurate approximations. Key Takeaway : CLT bridges the gap between non-normal populations and the powerful tools of normal distribution analysis.","title":"Exploring the Central Limit Theorem (CLT) Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-clt-through-simulations","text":"","title":"Exploring the Central Limit Theorem (CLT) Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a key concept in statistics: Regardless of the population's distribution, the distribution of the sample mean becomes approximately normal as the sample size increases. Why is this important? - It justifies using the normal distribution in many real-world situations. - Helps estimate population parameters. - Essential in quality control, finance, and data analysis.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-1-simulating-sampling-distributions","text":"","title":"Task 1 : Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-distributions","text":"We will use three types of populations: - Uniform : Equal chance across a range. - Exponential : Time between random events. - Binomial : Count of successes over trials. Python code --- import numpy as np def generate_population(dist, size=100000): if dist == \"uniform\": return np.random.uniform(0, 1, size) elif dist == \"exponential\": return np.random.exponential(scale=1.0, size=size) elif dist == \"binomial\": return np.random.binomial(n=10, p=0.5, size=size) ---","title":"Population Distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-2-sampling-and-visualization","text":"","title":"Task 2 : Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample-and-calculate-sample-means","text":"Python code import numpy as np import matplotlib.pyplot as plt # Define the simulation function def simulate_sampling(population, sample_size=30, n_samples=1000): return [ np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(n_samples) ] # Create a population (e.g., a normal distribution) population = np.random.normal(loc=50, scale=10, size=10000) # Simulate the sampling process sample_means = simulate_sampling(population, sample_size=30, n_samples=1000) # Plot the distribution of sample means plt.figure(figsize=(10, 6)) plt.hist(sample_means, bins=30, edgecolor='black', alpha=0.7) plt.title('Distribution of Sample Means') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.grid(True) plt.show()","title":"Sample and Calculate Sample Means:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualize-the-sampling-distributions","text":"Python code import matplotlib.pyplot as plt import seaborn as sns import numpy as np sns.set(style=\"whitegrid\") # Simulate sampling def simulate_sampling(population, sample_size=30, n_samples=1000): return [ np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(n_samples) ] # Generate different types of populations def generate_population(distribution_type, size=10000): if distribution_type == \"uniform\": return np.random.uniform(low=0, high=10, size=size) # Uniform distribution elif distribution_type == \"exponential\": return np.random.exponential(scale=1, size=size) # Exponential distribution elif distribution_type == \"binomial\": return np.random.binomial(n=10, p=0.5, size=size) # Binomial distribution else: raise ValueError(\"Unknown distribution type\") # Plot the sampling distribution def plot_sampling_distribution(dist_name, population): sample_sizes = [5, 10, 30, 50] plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes): sample_means = simulate_sampling(population, sample_size=size) plt.subplot(2, 2, i+1) sns.histplot(sample_means, bins=30, kde=True, color=\"skyblue\") plt.title(f\"{dist_name.capitalize()} Dist. - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.tight_layout() plt.suptitle(f\"CLT Simulation for {dist_name.capitalize()} Population\", fontsize=18, y=1.03) plt.show() # Example usage uniform_pop = generate_population(\"uniform\") plot_sampling_distribution(\"uniform\", uniform_pop)","title":"Visualize the Sampling Distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-3-parameter-exploration","text":"","title":"Task 3 : Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#run-simulations","text":"Python code # Uniform uniform_pop = generate_population(\"uniform\") plot_sampling_distribution(\"uniform\", uniform_pop) # Exponential exp_pop = generate_population(\"exponential\") plot_sampling_distribution(\"exponential\", exp_pop) # Binomial binom_pop = generate_population(\"binomial\") plot_sampling_distribution(\"binomial\", binom_pop) Uniform Population Distribution Exponential Population Distribution Biominal Population Distribution","title":"Run Simulations:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations","text":"Sample means tend toward normal shape. Variance of sample means decreases with sample size. Heavily skewed populations (e.g. exponential) require larger sample sizes.","title":"Observations:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-4-practical-applications-of-clt","text":"Manufacturing : Mean weight/size/quality of products. Polling : Estimating average opinions. Finance : Average return on investments. Science : Mean experimental measurements.","title":"Task 4 : Practical Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#why-it-works","text":"Sample means are sums of random variables. Sums tend to normality via CLT.","title":"Why It Works:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The CLT enables the use of normal-based statistical methods. Useful even when the population is not normally distributed. Larger sample sizes lead to more accurate approximations. Key Takeaway : CLT bridges the gap between non-normal populations and the powerful tools of normal distribution analysis.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}